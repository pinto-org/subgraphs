# This same entity schema is intended for use across the subgraphs
type Version @entity {
  "= 'subgraph'"
  id: ID!
  "= 'beanstalk'"
  subgraphName: String!
  "Verison number of the subgraph"
  versionNumber: String!
  "Address of Beanstalk protocol"
  protocolAddress: Bytes!
  "Which blockchain is being indexed, i.e. 'ethereum', 'arbitrum', etc."
  chain: String!
}

enum LiquidityEvent {
  # Additions
  ADD_LIQUIDITY
  SYNC
  # Removals
  REMOVE_LIQUIDITY
  REMOVE_LIQUIDITY_ONE_TOKEN
}

enum SwapEvent {
  SWAP
  SHIFT
}

type Account @entity {
  id: Bytes!
  deposits: [Deposit!]! @derivedFrom(field: "account")
  withdraws: [Withdraw!]! @derivedFrom(field: "account")
  swaps: [Swap!]! @derivedFrom(field: "account")
}

type Token @entity {
  "Smart contract address of the token"
  id: Bytes!
  "Name of the token, mirrored from the smart contract"
  name: String!
  "Symbol of the token, mirrored from the smart contract"
  symbol: String!
  "The number of decimal places this token uses, default to 18"
  decimals: Int!
  "Optional field to track the price of a token, mostly for caching purposes"
  lastPriceUSD: BigDecimal!
  "Optional field to track the block number of the last token price"
  lastPriceBlockNumber: BigInt!
}

type WellUpgradeHistory @entity {
  "{Well Address}-{Upgrade Index} "
  id: ID!
  "The well that this upgrade history is for"
  well: Well!
  "The block this upgrade went into effect"
  effectiveBlock: BigInt!
  "The timestamp this upgrade went into effect"
  effectiveTimestamp: BigInt!
  ##### Datapoints #####
  boredWell: Bytes!
  aquifer: Aquifer!
  implementation: Implementation!
  pumps: [Pump!]!
  pumpData: [Bytes!]!
  wellFunction: WellFunction!
  wellFunctionData: Bytes!
}

type Aquifer @entity {
  "Smart contract address of the aquifer"
  id: Bytes!
  "Wells deployed by this aquifer"
  wells: [Well!]! @derivedFrom(field: "aquifer")
}

type Implementation @entity {
  "Implementation address"
  id: Bytes!
  "Wells deployed with this implementation"
  wells: [Well!]! @derivedFrom(field: "implementation")
}

type WellFunction @entity {
  "Well Function address"
  id: Bytes!
  "Wells associated with this well function"
  wells: [Well!]! @derivedFrom(field: "wellFunction")
}

type Pump @entity {
  "Pump address"
  id: Bytes!
  "Wells associated with this pump"
  wells: [Well!]! @derivedFrom(field: "pumps")
}

type Season @entity {
  "Season number (string)"
  id: ID!
  "Season number (int) "
  season: Int!
  "Timestamp of the start of this season"
  timestamp: BigInt!

  # Snapshots
  wellHourlySnapshots: [WellHourlySnapshot!]! @derivedFrom(field: "season")
  wellDailySnapshots: [WellDailySnapshot!]! @derivedFrom(field: "season")
}

# Contains cumulative stats across all of the Beanstalk wells.
type Beanstalk @entity {
  "= 'beanstalk'"
  id: ID!

  "Last season seen from Beanstalk"
  lastSeason: Season!

  "Beanstalk Wells"
  wells: [Well!]!

  "The sum of all liquidity in USD all wells."
  totalLiquidityUSD: BigDecimal!

  "All trade volume occurred, in USD. This includes any net trading activity as a result of add/remove liquidity."
  cumulativeTradeVolumeUSD: BigDecimal!

  "All transfer volume occurred, in USD. This includes the full value of tokens transferred in add/remove liquidity."
  cumulativeTransferVolumeUSD: BigDecimal!

  "Total number of deposit events (add liquidity) "
  cumulativeDepositCount: Int!

  "Total number of withdrawal events (remove liquidity) "
  cumulativeWithdrawCount: Int!

  "Total number of trades (swaps) "
  cumulativeSwapCount: Int!

  "Current rolling 24h trade volume in USD"
  rollingDailyTradeVolumeUSD: BigDecimal!

  "Current rolling 24h transfer volume in USD"
  rollingDailyTransferVolumeUSD: BigDecimal!

  "Current rolling weekly trade volume in USD"
  rollingWeeklyTradeVolumeUSD: BigDecimal!

  "Current rolling weekly transfer volume in USD"
  rollingWeeklyTransferVolumeUSD: BigDecimal!

  "Day ID of the most recent daily snapshot"
  lastSnapshotDayID: Int!

  "Hour ID of the most recent hourly snapshot"
  lastSnapshotHourID: Int!

  "Timestamp of the last time this entity was updated"
  lastUpdateTimestamp: BigInt!

  "Block number of the last time this entity was updated"
  lastUpdateBlockNumber: BigInt!
}

type BeanstalkHourlySnapshot @entity {
  "Season number (string)"
  id: ID!

  "Season"
  season: Season!

  "The sum of all liquidity in USD all wells."
  totalLiquidityUSD: BigDecimal!

  "All trade volume occurred, in USD. This includes any net trading activity as a result of add/remove liquidity."
  cumulativeTradeVolumeUSD: BigDecimal!

  "All transfer volume occurred, in USD. This includes the full value of tokens transferred in add/remove liquidity."
  cumulativeTransferVolumeUSD: BigDecimal!

  "Total number of deposit events (add liquidity) "
  cumulativeDepositCount: Int!

  "Total number of withdrawal events (remove liquidity) "
  cumulativeWithdrawCount: Int!

  "Total number of trades (swaps) "
  cumulativeSwapCount: Int!

  ##### Delta Amounts #####

  "Delta of totalLiquidityUSD"
  deltaLiquidityUSD: BigDecimal!

  "Delta of cumulativeTradeVolumeUSD"
  deltaTradeVolumeUSD: BigDecimal!

  "Delta of cumulativeTransferVolumeUSD"
  deltaTransferVolumeUSD: BigDecimal!

  "Delta of cumulativeDepositCount"
  deltaDepositCount: Int!

  "Delta of cumulativeDepositCount"
  deltaWithdrawCount: Int!

  "Delta of cumulativeDepositCount"
  deltaSwapCount: Int!

  "Timestamp of the last time this entity was updated"
  lastUpdateTimestamp: BigInt!

  "Block number of the last time this entity was updated"
  lastUpdateBlockNumber: BigInt!
}

type BeanstalkDailySnapshot @entity {
  "Unix day (string)"
  id: ID!

  "Unix day (int)"
  day: Int!

  "Season"
  season: Season!

  "The sum of all liquidity in USD all wells."
  totalLiquidityUSD: BigDecimal!

  "All trade volume occurred, in USD. This includes any net trading activity as a result of add/remove liquidity."
  cumulativeTradeVolumeUSD: BigDecimal!

  "All transfer volume occurred, in USD. This includes the full value of tokens transferred in add/remove liquidity."
  cumulativeTransferVolumeUSD: BigDecimal!

  "Total number of deposit events (add liquidity) "
  cumulativeDepositCount: Int!

  "Total number of withdrawal events (remove liquidity) "
  cumulativeWithdrawCount: Int!

  "Total number of trades (swaps) "
  cumulativeSwapCount: Int!

  ##### Delta Amounts #####

  "Delta of totalLiquidityUSD"
  deltaLiquidityUSD: BigDecimal!

  "Delta of cumulativeTradeVolumeUSD"
  deltaTradeVolumeUSD: BigDecimal!

  "Delta of cumulativeTransferVolumeUSD"
  deltaTransferVolumeUSD: BigDecimal!

  "Delta of cumulativeDepositCount"
  deltaDepositCount: Int!

  "Delta of cumulativeDepositCount"
  deltaWithdrawCount: Int!

  "Delta of cumulativeDepositCount"
  deltaSwapCount: Int!

  "Timestamp of the last time this entity was updated"
  lastUpdateTimestamp: BigInt!

  "Block number of the last time this entity was updated"
  lastUpdateBlockNumber: BigInt!
}

type Well @entity {
  "Well address. For upgradeable wells, this is the proxy address."
  id: Bytes!

  "The bored well address. Differs from `id` in the case of an Upgradeable well."
  boredWell: Bytes!

  "The aquifer used to bore this well"
  aquifer: Aquifer!

  "The well implementation used to deploy this well"
  implementation: Implementation!

  "Pumps associated with this well"
  pumps: [Pump!]!

  "Data to be passed to each pump"
  pumpData: [Bytes!]!

  "Pricing function contract used with this well"
  wellFunction: WellFunction!

  "Data to be passed to the well function"
  wellFunctionData: Bytes!

  "Name of liquidity well (e.g. Curve.fi DAI/USDC/USDT) "
  name: String

  "Symbol of liquidity well (e.g. 3CRV) "
  symbol: String

  "Tokens that need to be deposited to take a position in protocol. e.g. WETH and USDC to deposit into the WETH-USDC well. Array to account for multi-asset wells like Curve and Balancer"
  tokens: [Token!]!

  "The order of the tokens in the Well. The above `tokens` association will be sorted by id on any retrieval."
  tokenOrder: [Bytes!]!

  "Creation timestamp"
  createdTimestamp: BigInt!

  "Creation block number"
  createdBlockNumber: BigInt!

  "History of upgrades (for upgradeable wells). All wells will have at least one entry here."
  upgradeHistory: [WellUpgradeHistory!]! @derivedFrom(field: "well")

  ##### Quantitative Data #####

  "Total liquidity token supply for the well."
  lpTokenSupply: BigInt!

  "The sum of all active and non-active liquidity in USD for this well."
  totalLiquidityUSD: BigDecimal!

  "The current amount of each token needed to exchange for one of the other token."
  tokenPrice: [BigInt!]!

  "Amount of each token in the well. The ordering should be the same as the well's `tokens` field."
  reserves: [BigInt!]!

  "USD value of each token in the well. The ordering should be the same as the well's `tokens` field."
  reservesUSD: [BigDecimal!]!

  "All trade volume occurred for a specific token, in native amount. Volume for an individual token is defined as a purchase of that token. This includes any net trading activity as a result of add/remove liquidity. The ordering should be the same as the well's `tokens` field."
  cumulativeTradeVolumeReserves: [BigInt!]!

  "All trade volume occurred for a specific token, in USD. Volume for an individual token is defined as a purchase of that token. This includes any net trading activity as a result of add/remove liquidity. The ordering should be the same as the well's `tokens` field."
  cumulativeTradeVolumeReservesUSD: [BigDecimal!]!

  "All trade volume occurred in this well, in USD. This includes any net trading activity as a result of add/remove liquidity. Should be equal to the sum of all entries in cumulativeTradeVolumeReservesUSD"
  cumulativeTradeVolumeUSD: BigDecimal!

  "All trade volume occurred for a specific token, in native amount. This includes absolute tokens on both sides of the trade unlike cumulativeTradeVolumeReserves. This includes any net trading activity as a result of add/remove liquidity. The ordering should be the same as the well's `tokens` field."
  cumulativeBiTradeVolumeReserves: [BigInt!]!

  "All transfer volume occurred for a specific token, in native amount. This includes the full amount of tokens transferred in add/remove liquidity. The ordering should be the same as the well's `tokens` field."
  cumulativeTransferVolumeReserves: [BigInt!]!

  "All transfer volume occurred for a specific token, in USD. This includes the full value of tokens transferred in add/remove liquidity. The ordering should be the same as the well's `tokens` field."
  cumulativeTransferVolumeReservesUSD: [BigDecimal!]!

  "All transfer volume occurred in this well, in USD. This includes the full value of tokens transferred in add/remove liquidity. Should be equal to the sum of all entries in cumulativeTransferVolumeReservesUSD"
  cumulativeTransferVolumeUSD: BigDecimal!

  "Total number of deposit events (add liquidity) "
  cumulativeDepositCount: Int!

  "Total number of withdrawal events (remove liquidity) "
  cumulativeWithdrawCount: Int!

  "Total number of trades (swaps) "
  cumulativeSwapCount: Int!

  "Current rolling 24h reserve trade volume in token amounts"
  rollingDailyTradeVolumeReserves: [BigInt!]!

  "Current rolling 24h reserve trade volume in USD"
  rollingDailyTradeVolumeReservesUSD: [BigDecimal!]!

  "Current rolling 24h trade volume in USD"
  rollingDailyTradeVolumeUSD: BigDecimal!

  "Current rolling 24h reserve trade volume in token amounts, including absolute tokens on both side of the trade unlike rollingDailyTradeVolumeReserves."
  rollingDailyBiTradeVolumeReserves: [BigInt!]!

  "Current rolling 24h reserve transfer volume in token amounts"
  rollingDailyTransferVolumeReserves: [BigInt!]!

  "Current rolling 24h reserve transfer volume in USD"
  rollingDailyTransferVolumeReservesUSD: [BigDecimal!]!

  "Current rolling 24h transfer volume in USD"
  rollingDailyTransferVolumeUSD: BigDecimal!

  "Current rolling weekly reserve trade volume in token amounts"
  rollingWeeklyTradeVolumeReserves: [BigInt!]!

  "Current rolling weekly reserve trade volume in USD"
  rollingWeeklyTradeVolumeReservesUSD: [BigDecimal!]!

  "Current rolling weekly trade volume in USD"
  rollingWeeklyTradeVolumeUSD: BigDecimal!

  "Current rolling weekly reserve trade volume in token amounts, including absolute tokens on both side of the trade unlike rollingWeeklyTradeVolumeReserves."
  rollingWeeklyBiTradeVolumeReserves: [BigInt!]!

  "Current rolling weekly reserve transfer volume in token amounts"
  rollingWeeklyTransferVolumeReserves: [BigInt!]!

  "Current rolling weekly reserve transfer volume in USD"
  rollingWeeklyTransferVolumeReservesUSD: [BigDecimal!]!

  "Current rolling weekly transfer volume in USD"
  rollingWeeklyTransferVolumeUSD: BigDecimal!

  "Day ID of the most recent daily snapshot"
  lastSnapshotDayID: Int!

  "Hour ID of the most recent hourly snapshot"
  lastSnapshotHourID: Int!

  "Timestamp of the last time this entity was updated"
  lastUpdateTimestamp: BigInt!

  "Block number of the last time this entity was updated"
  lastUpdateBlockNumber: BigInt!

  ##### Snapshots #####

  "Liquidity well daily snapshots"
  dailySnapshots: [WellDailySnapshot!]! @derivedFrom(field: "well")

  "Liquidity well hourly snapshots"
  hourlySnapshots: [WellHourlySnapshot!]! @derivedFrom(field: "well")

  ##### Events #####

  "All deposit (add liquidity) events occurred in this well"
  deposits: [Deposit!]! @derivedFrom(field: "well")

  "All withdraw (remove liquidity) events occurred in this well"
  withdraws: [Withdraw!]! @derivedFrom(field: "well")

  "All trade (swap) events occurred in this well"
  swaps: [Swap!]! @derivedFrom(field: "well")
}

type WellHourlySnapshot @entity {
  "{Smart contract address of the well}-{Season number} "
  id: Bytes!

  "Season"
  season: Season!

  "Number of hours since Unix epoch time"
  hour: Int!

  "The well this snapshot belongs to"
  well: Well!

  ##### Cumulative Data #####

  "Total liquidity token supply for the well."
  lpTokenSupply: BigInt!

  "The sum of all active and non-active liquidity in USD for this well."
  totalLiquidityUSD: BigDecimal!

  "The current amount of each token needed to exchange for one of the other token."
  tokenPrice: [BigInt!]!

  "All trade volume occurred for a specific token, in native amount. Volume for an individual token is defined as a purchase of that token. This includes any net trading activity as a result of add/remove liquidity. The ordering should be the same as the well's `tokens` field."
  cumulativeTradeVolumeReserves: [BigInt!]!

  "All trade volume occurred for a specific token, in USD. Volume for an individual token is defined as a purchase of that token. This includes any net trading activity as a result of add/remove liquidity. The ordering should be the same as the well's `tokens` field."
  cumulativeTradeVolumeReservesUSD: [BigDecimal!]!

  "All trade volume occurred in this well, in USD. This includes any net trading activity as a result of add/remove liquidity. Should be equal to the sum of all entries in cumulativeTradeVolumeReservesUSD"
  cumulativeTradeVolumeUSD: BigDecimal!

  "All trade volume occurred for a specific token, in native amount. This includes absolute tokens on both sides of the trade unlike cumulativeTradeVolumeReserves. This includes any net trading activity as a result of add/remove liquidity. The ordering should be the same as the well's `tokens` field."
  cumulativeBiTradeVolumeReserves: [BigInt!]!

  "All transfer volume occurred for a specific token, in native amount. This includes the full amount of tokens transferred in add/remove liquidity. The ordering should be the same as the well's `tokens` field."
  cumulativeTransferVolumeReserves: [BigInt!]!

  "All transfer volume occurred for a specific token, in USD. This includes the full value of tokens transferred in add/remove liquidity. The ordering should be the same as the well's `tokens` field."
  cumulativeTransferVolumeReservesUSD: [BigDecimal!]!

  "All transfer volume occurred in this well, in USD. This includes the full value of tokens transferred in add/remove liquidity. Should be equal to the sum of all entries in cumulativeTransferVolumeReservesUSD"
  cumulativeTransferVolumeUSD: BigDecimal!

  "Total number of deposit events (add liquidity) "
  cumulativeDepositCount: Int!

  "Total number of withdrawal events (remove liquidity) "
  cumulativeWithdrawCount: Int!

  "Total number of trades (swaps) "
  cumulativeSwapCount: Int!

  ##### Delta Amounts #####

  "Total liquidity token supply for the well."
  deltalpTokenSupply: BigInt!

  "The sum of all active and non-active liquidity in USD for this well."
  deltaLiquidityUSD: BigDecimal!

  "Delta of cumulativeTradeVolumeReserves"
  deltaTradeVolumeReserves: [BigInt!]!

  "Delta of cumulativeTradeVolumeReservesUSD"
  deltaTradeVolumeReservesUSD: [BigDecimal!]!

  "Delta of cumulativeTradeVolumeUSD"
  deltaTradeVolumeUSD: BigDecimal!

  "Delta of cumulativeBiTradeVolumeReserves"
  deltaBiTradeVolumeReserves: [BigInt!]!

  "Delta of cumulativeTransferVolumeReserves"
  deltaTransferVolumeReserves: [BigInt!]!

  "Delta of cumulativeTransferVolumeReservesUSD"
  deltaTransferVolumeReservesUSD: [BigDecimal!]!

  "Delta of cumulativeTransferVolumeUSD"
  deltaTransferVolumeUSD: BigDecimal!

  "Total number of deposit events (add liquidity) "
  deltaDepositCount: Int!

  "Total number of withdrawal events (remove liquidity) "
  deltaWithdrawCount: Int!

  "Total number of trades (swaps) "
  deltaSwapCount: Int!

  "Timestamp of the last time this entity was updated"
  lastUpdateTimestamp: BigInt!

  "Block number of the last time this entity was updated"
  lastUpdateBlockNumber: BigInt!
}

type WellDailySnapshot @entity {
  "{Smart contract address of the well}-{ # of days since Unix epoch time } "
  id: Bytes!

  "Season"
  season: Season!

  "Number of days since Unix epoch time"
  day: Int!

  "The well this snapshot belongs to"
  well: Well!

  ##### Cumulative Data #####

  "Total liquidity token supply for the well."
  lpTokenSupply: BigInt!

  "The sum of all active and non-active liquidity in USD for this well."
  totalLiquidityUSD: BigDecimal!

  "The current amount of each token needed to exchange for one of the other token."
  tokenPrice: [BigInt!]!

  "All trade volume occurred for a specific token, in native amount. Volume for an individual token is defined as a purchase of that token. This includes any net trading activity as a result of add/remove liquidity. The ordering should be the same as the well's `tokens` field."
  cumulativeTradeVolumeReserves: [BigInt!]!

  "All trade volume occurred for a specific token, in USD. Volume for an individual token is defined as a purchase of that token. This includes any net trading activity as a result of add/remove liquidity. The ordering should be the same as the well's `tokens` field."
  cumulativeTradeVolumeReservesUSD: [BigDecimal!]!

  "All trade volume occurred in this well, in USD. This includes any net trading activity as a result of add/remove liquidity. Should be equal to the sum of all entries in cumulativeTradeVolumeReservesUSD"
  cumulativeTradeVolumeUSD: BigDecimal!

  "All trade volume occurred for a specific token, in native amount. This includes absolute tokens on both sides of the trade unlike cumulativeTradeVolumeReserves. This includes any net trading activity as a result of add/remove liquidity. The ordering should be the same as the well's `tokens` field."
  cumulativeBiTradeVolumeReserves: [BigInt!]!

  "All transfer volume occurred for a specific token, in native amount. This includes the full amount of tokens transferred in add/remove liquidity. The ordering should be the same as the well's `tokens` field."
  cumulativeTransferVolumeReserves: [BigInt!]!

  "All transfer volume occurred for a specific token, in USD. This includes the full value of tokens transferred in add/remove liquidity. The ordering should be the same as the well's `tokens` field."
  cumulativeTransferVolumeReservesUSD: [BigDecimal!]!

  "All transfer volume occurred in this well, in USD. This includes the full value of tokens transferred in add/remove liquidity. Should be equal to the sum of all entries in cumulativeTransferVolumeReservesUSD"
  cumulativeTransferVolumeUSD: BigDecimal!

  "Total number of deposit events (add liquidity) "
  cumulativeDepositCount: Int!

  "Total number of withdrawal events (remove liquidity) "
  cumulativeWithdrawCount: Int!

  "Total number of trades (swaps) "
  cumulativeSwapCount: Int!

  ##### Delta Amounts #####

  "Total liquidity token supply for the well."
  deltalpTokenSupply: BigInt!

  "The sum of all active and non-active liquidity in USD for this well."
  deltaLiquidityUSD: BigDecimal!

  "Delta of cumulativeTradeVolumeReserves"
  deltaTradeVolumeReserves: [BigInt!]!

  "Delta of cumulativeTradeVolumeReservesUSD"
  deltaTradeVolumeReservesUSD: [BigDecimal!]!

  "Delta of cumulativeTradeVolumeUSD"
  deltaTradeVolumeUSD: BigDecimal!

  "Delta of cumulativeBiTradeVolumeReserves"
  deltaBiTradeVolumeReserves: [BigInt!]!

  "Delta of cumulativeTransferVolumeReserves"
  deltaTransferVolumeReserves: [BigInt!]!

  "Delta of cumulativeTransferVolumeReservesUSD"
  deltaTransferVolumeReservesUSD: [BigDecimal!]!

  "Delta of cumulativeTransferVolumeUSD"
  deltaTransferVolumeUSD: BigDecimal!

  "Total number of deposit events (add liquidity) "
  deltaDepositCount: Int!

  "Total number of withdrawal events (remove liquidity) "
  deltaWithdrawCount: Int!

  "Total number of trades (swaps) "
  deltaSwapCount: Int!

  "Timestamp of the last time this entity was updated"
  lastUpdateTimestamp: BigInt!

  "Block number of the last time this entity was updated"
  lastUpdateBlockNumber: BigInt!
}

##### EVENT LEVEL ENTITIES #####

# This maps to the AddLiquidity and Sync events
type Deposit @entity(immutable: true) {
  "{Transaction hash}-{Well}-{LP token amount}(-{log index})? | The ID is constructed in this fashion to allow any subsequent event in the same transaction to identify this entity. (Adds log index if necessary to prevent collision)"
  id: ID!

  "Transaction hash of the transaction that emitted this event"
  hash: Bytes!

  "Event log index."
  logIndex: Int!

  "The well involving this event"
  well: Well!

  "Account that emitted this event"
  account: Account!

  "Event type that was emitted"
  eventType: LiquidityEvent!

  "Amount of liquidity tokens minted"
  liquidity: BigInt!

  "Input tokens of the well. E.g. WETH and USDC to a WETH-USDC well"
  tokens: [Token!]!

  "Amount of input tokens in the token's native unit"
  reserves: [BigInt!]!

  "USD-normalized value of the transaction of the underlying (e.g. sum of tokens deposited into a well) "
  amountUSD: BigDecimal!

  "The current amount of each token needed to exchange for one of the other token, after this event."
  tokenPrice: [BigInt!]!

  "Boolean indicating whether this liquidity addition is a Beanstalk convert."
  isConvert: Boolean!

  "Trade volume for each token, in native amount, as a result of this liquidity addition. The ordering should be the same as the well's `tokens` field."
  tradeVolumeReserves: [BigInt!]!

  "Trade volume for each token, in USD, as a result of this liquidity addition. The ordering should be the same as the well's `tokens` field."
  tradeVolumeReservesUSD: [BigDecimal!]!

  "Trade volume in USD as a result of this liquidity addition."
  tradeVolumeUSD: BigDecimal!

  "Same as tradeVolumeReserves, but further includes absolute tokens on both sides of the effective trade."
  biTradeVolumeReserves: [BigInt!]!

  "Transfer volume for each token, in native amount. The ordering should be the same as the well's `tokens` field."
  transferVolumeReserves: [BigInt!]!

  "Transfer volume for each token, in USD. The ordering should be the same as the well's `tokens` field."
  transferVolumeReservesUSD: [BigDecimal!]!

  "Transfer volume in USD as a result of this liquidity addition."
  transferVolumeUSD: BigDecimal!

  "Block number of this event"
  blockNumber: BigInt!

  "Timestamp of this event"
  timestamp: BigInt!
}

# This maps to RemoveLiquidity and RemoveLiquidityOneToken events
type Withdraw @entity(immutable: true) {
  "{Transaction hash}-{Well}-{LP token amount}(-{log index})? | The ID is constructed in this fashion to allow any subsequent event in the same transaction to identify this entity. (Adds log index if necessary to prevent collision)"
  id: ID!

  "Transaction hash of the transaction that emitted this event"
  hash: Bytes!

  "Event log index."
  logIndex: Int!

  "The well involving this event"
  well: Well!

  "Account that emitted this event"
  account: Account!

  "Event type that was emitted"
  eventType: LiquidityEvent!

  "Amount of liquidity tokens burned"
  liquidity: BigInt!

  "Input tokens of the well (not input tokens of the event/transaction). E.g. WETH and USDC from a WETH-USDC well"
  tokens: [Token!]!

  "Amount of input tokens in the token's native unit"
  reserves: [BigInt!]!

  "USD-normalized value of the transaction of the underlying (e.g. sum of tokens withdrawn from a well) "
  amountUSD: BigDecimal!

  "The current amount of each token needed to exchange for one of the other token, after this event."
  tokenPrice: [BigInt!]!

  "Boolean indicating whether this liquidity removal is a Beanstalk convert."
  isConvert: Boolean!

  "Trade volume for each token, in native amount, as a result of this liquidity removal. The ordering should be the same as the well's `tokens` field."
  tradeVolumeReserves: [BigInt!]!

  "Trade volume for each token, in USD, as a result of this liquidity removal. The ordering should be the same as the well's `tokens` field."
  tradeVolumeReservesUSD: [BigDecimal!]!

  "Trade volume in USD as a result of this liquidity removal."
  tradeVolumeUSD: BigDecimal!

  "Same as tradeVolumeReserves, but further includes absolute tokens on both sides of the effective trade."
  biTradeVolumeReserves: [BigInt!]!

  "Transfer volume for each token, in native amount. The ordering should be the same as the well's `tokens` field."
  transferVolumeReserves: [BigInt!]!

  "Transfer volume for each token, in USD. The ordering should be the same as the well's `tokens` field."
  transferVolumeReservesUSD: [BigDecimal!]!

  "Transfer volume in USD as a result of this liquidity removal."
  transferVolumeUSD: BigDecimal!

  "Block number of this event"
  blockNumber: BigInt!

  "Timestamp of this event"
  timestamp: BigInt!
}

type Swap @entity(immutable: true) {
  "{Transaction hash}-{Well}-{Out token amount}(-{log index})? | The ID is constructed in this fashion to allow any subsequent event in the same transaction to identify this entity. (Adds log index if necessary to prevent collision)"
  id: ID!

  "Transaction hash of the event"
  hash: Bytes!

  "Log index of the event"
  logIndex: Int!

  "Well involving this event"
  well: Well!

  "Address that sent the transaction"
  account: Account!

  "Event type that was emitted"
  eventType: SwapEvent!

  "Token deposited into the well"
  fromToken: Token!

  "Amount of token deposited into the well in native units"
  amountIn: BigInt!

  "Token withdrawn from the well"
  toToken: Token!

  "Amount of the token withdrawn from the well in native units"
  amountOut: BigInt!

  "The current amount of each token needed to exchange for one of the other token, after this event."
  tokenPrice: [BigInt!]!

  "Trade volume for each token, in native amount, as a result of this swap. The ordering should be the same as the well's `tokens` field."
  tradeVolumeReserves: [BigInt!]!

  "Trade volume for each token, in USD, as a result of this swap. The ordering should be the same as the well's `tokens` field."
  tradeVolumeReservesUSD: [BigDecimal!]!

  "Trade volume in USD as a result of this swap."
  tradeVolumeUSD: BigDecimal!

  "Same as tradeVolumeReserves, but further includes absolute tokens on both sides of the trade."
  biTradeVolumeReserves: [BigInt!]!

  "Transfer volume for each token, in native amount. The ordering should be the same as the well's `tokens` field."
  transferVolumeReserves: [BigInt!]!

  "Transfer volume for each token, in USD. The ordering should be the same as the well's `tokens` field."
  transferVolumeReservesUSD: [BigDecimal!]!

  "Transfer volume in USD as a result of this swap."
  transferVolumeUSD: BigDecimal!

  "Block number of this event"
  blockNumber: BigInt!

  "Timestamp of this event"
  timestamp: BigInt!
}
