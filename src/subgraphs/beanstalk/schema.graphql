# This same entity schema is intended for use across the subgraphs
type Version @entity {
  "= 'subgraph'"
  id: ID!
  "= 'beanstalk'"
  subgraphName: String!
  "Verison number of the subgraph"
  versionNumber: String!
  "Address of Beanstalk protocol"
  protocolAddress: Bytes!
  "Which blockchain is being indexed, i.e. 'ethereum', 'arbitrum', etc."
  chain: String!
}

enum MarketStatus {
  ACTIVE
  FILLED
  FILLED_PARTIAL
  CANCELLED
  CANCELLED_PARTIAL
  EXPIRED
}

enum PlotSource {
  SOW
  TRANSFER
  MARKET
  RESEED_MIGRATED
  CONTRACT_RECEIVER_MIGRATED
}

enum EmaWindow {
  ROLLING_24_HOUR
  ROLLING_7_DAY
  ROLLING_30_DAY
}

type Beanstalk @entity {
  "'beanstalk'"
  id: ID!
  "Bean token address of the protocol"
  token: Bytes!
  "Supported wrapped deposit tokens"
  wrappedDepositTokens: [WrappedDepositERC20!]! @derivedFrom(field: "beanstalk")
  "Address of the fertilizer contract"
  fertilizer1155: Bytes
  "Season specific data"
  seasons: [Season!]! @derivedFrom(field: "beanstalk")
  "Silo level data"
  silo: Silo! @derivedFrom(field: "beanstalk")
  "Field level data"
  field: Field! @derivedFrom(field: "beanstalk")
  "Last season called"
  lastSeason: Int!
  "Array of the addresses for all active farmers in the silo"
  activeFarmers: [Bytes!]!
  "Array of the addresses for all farmers that had silo transfers and need stalk/roots updated"
  farmersToUpdate: [Bytes!]!
}

type Season @entity {
  "Season Number"
  id: ID!
  "'beanstalk'"
  beanstalk: Beanstalk!
  "Season number in Int form for sorting"
  season: Int!
  "Block in which the season start was triggered by the sunrise call"
  sunriseBlock: BigInt!
  "Block timestamp when sunrise was called"
  createdAt: BigInt!
  "Price of BEAN during sunrise"
  price: BigDecimal!
  "Total Bean supply"
  beans: BigInt!
  "Beans from L1 which have not migrated yet"
  unmigratedL1Beans: BigInt
  "Bean Market Cap"
  marketCap: BigDecimal!
  "Time weighted deltaB"
  deltaB: BigInt!
  "Delta of beans"
  deltaBeans: BigInt!
  "Amount of Beans minted during sunrise from TWA. Does not include flood mints"
  rewardBeans: BigInt!
  "Amount of beans minted to the Field due to the flood"
  floodFieldBeans: BigInt!
  "Amount of beans minted to the Silo due to the flood"
  floodSiloBeans: BigInt!
  "Amount of Beans paid to sunrise caller"
  incentiveBeans: BigInt!
  "Boolean indicating whether the system is currently raining"
  raining: Boolean!
}

type WellPlenty @entity {
  "{Address for the farmer or Beanstalk contract}-{Non-Pinto token}"
  id: ID!
  "Beanstalk or farmer silo (used in the ID)"
  silo: Silo!
  "Payout token (used in the ID)"
  token: Bytes!
  "The amount of unclaimed plenty for this token. Always = 0 for an individual Farmer's Silo."
  unclaimedAmount: BigInt!
  "The amount of claimed plenty for this token"
  claimedAmount: BigInt!
}

type Silo @entity {
  "Address for the farmer or Beanstalk contract"
  id: Bytes!
  "'beanstalk'"
  beanstalk: Beanstalk!
  "Farmer address if applicable"
  farmer: Farmer

  "Link to all silo assets currently associated with this silo"
  assets: [SiloAsset!]! @derivedFrom(field: "silo")
  "Current stalk balance"
  stalk: BigInt!
  "Current BDV of all deposited assets"
  depositedBDV: BigInt!
  "Cumulative total of beans that have been Planted"
  plantedBeans: BigInt!
  "Current roots balance"
  roots: BigInt!
  "[Seed Gauge] Stalk that is currently Germinating"
  germinatingStalk: BigInt!
  "Total stalk amount that has been penalized by the convert down penalty"
  penalizedStalkConvertDown: BigInt!
  "Total amount of stalk that was not penalized during the application of a down convert penalty. Needed to compute the avg penalty rate"
  unpenalizedStalkConvertDown: BigInt!
  "Average convert down penalty that has been assessed, in percent"
  avgConvertDownPenalty: BigDecimal!
  "Total grown stalk gained via the Convert Up Bonus"
  bonusStalkConvertUp: BigInt!
  "Total BDV converted up that was awarded the bonus"
  totalBdvConvertUpBonus: BigInt!
  "Total BDV converted up regardless of receiving a bonus. (!) This value accumulates only when the Convert Up Bonus (gauge id 2) is active."
  totalBdvConvertUp: BigInt!

  "(protocol) Tokens whitelisted for deposit within the silo"
  whitelistedTokens: [Bytes!]!
  "(protocol) Tokens that have been removed from the silo deposit whitelist"
  dewhitelistedTokens: [Bytes!]!
  "(protocol) Tokens in the order they were whitelisted for deposit. This list never shrinks."
  allWhitelistedTokens: [Bytes!]!
  "(protocol) Cumulative total for bean mints sent to the silo"
  beanMints: BigInt!
  "(protocol) Current plantable stalk for bean seigniorage not yet claimed"
  plantableStalk: BigInt!
  "(protocol) [Seed Gauge] Current target ratio of Bean to LP deposits"
  beanToMaxLpGpPerBdvRatio: BigInt!
  "(protocol) Value emitted by UpdateAverageStalkPerBdvPerSeason event"
  avgGrownStalkPerBdvPerSeason: BigInt!
  "(protocol) Current grown stalk per season according to avgGrownStalkPerBdvPerSeason"
  grownStalkPerSeason: BigInt!
  "(protocol) PI-7 Convert down penalty"
  convertDownPenalty: BigDecimal
  "(protocol) Current number of active farmers deposited in the silo"
  activeFarmers: Int!
  "(protocol) Deposited BDV from L1 which has not migrated yet"
  unmigratedL1DepositedBdv: BigInt

  "(protocol) Market performance for each season"
  marketPerformanceSeasonals: [MarketPerformanceSeasonal!]! @derivedFrom(field: "silo")

  "Season when the previous hourly snapshot was taken/updated"
  lastHourlySnapshotSeason: Int
  "Day of when the previous daily snapshot was taken/updated"
  lastDailySnapshotDay: BigInt
  "Link to hourly snapshot data"
  hourlySnapshots: [SiloHourlySnapshot!]! @derivedFrom(field: "silo")
  "Link to daily snapshot data"
  dailySnapshots: [SiloDailySnapshot!]! @derivedFrom(field: "silo")
}

type SiloHourlySnapshot @entity {
  "ID of silo - Season"
  id: ID!
  "Season for the snapshot"
  season: Int!
  "Silo associated with the snapshot"
  silo: Silo!
  "Point in time current stalk balance"
  stalk: BigInt!
  "Point in time current BDV of all deposited assets"
  depositedBDV: BigInt!
  "Point in time total of beans that have been Planted"
  plantedBeans: BigInt!
  "Point in time current roots balance"
  roots: BigInt!
  "[Seed Gauge] Stalk that is currently Germinating"
  germinatingStalk: BigInt!
  "Point in time total stalk that has been penalized by the convert down penalty"
  penalizedStalkConvertDown: BigInt!
  "Point in time totalstalk that was not penalized during the application of a down convert penalty"
  unpenalizedStalkConvertDown: BigInt!
  "Average convert down penalty that has been assessed, in percent. 20.5 = 20.5%"
  avgConvertDownPenalty: BigDecimal!
  "Point in time total grown stalk gained via the Convert Up Bonus"
  bonusStalkConvertUp: BigInt!
  "Point in time total BDV converted up that was awarded the bonus"
  totalBdvConvertUpBonus: BigInt!
  "Point in time total BDV converted up regardless of receiving a bonus. (!) This value accumulates only when the Convert Up Bonus (gauge id 2) is active."
  totalBdvConvertUp: BigInt!

  "Point in time cumulative total for bean mints sent to the silo"
  beanMints: BigInt!
  "Point in time current plantable stalk for bean seigniorage not yet claimed (only set on protocol-level Silo)"
  plantableStalk: BigInt!
  "[Seed Gauge] Current target ratio of Bean to LP deposits"
  beanToMaxLpGpPerBdvRatio: BigInt!
  "Point in time average grown stalk per bdv per season"
  avgGrownStalkPerBdvPerSeason: BigInt!
  "Point in time grown stalk per season"
  grownStalkPerSeason: BigInt!
  "Point in time PI-7 convert down penalty)"
  convertDownPenalty: BigDecimal
  "Point in time active farmers"
  activeFarmers: Int!

  deltaStalk: BigInt!
  deltaDepositedBDV: BigInt!
  deltaPlantedBeans: BigInt!
  deltaRoots: BigInt!
  deltaGerminatingStalk: BigInt!
  deltaPenalizedStalkConvertDown: BigInt!
  deltaUnpenalizedStalkConvertDown: BigInt!
  deltaAvgConvertDownPenalty: BigDecimal!
  deltaBonusStalkConvertUp: BigInt!
  deltaTotalBdvConvertUpBonus: BigInt!
  deltaTotalBdvConvertUp: BigInt!
  deltaBeanMints: BigInt!
  deltaPlantableStalk: BigInt!
  deltaBeanToMaxLpGpPerBdvRatio: BigInt!
  deltaAvgGrownStalkPerBdvPerSeason: BigInt!
  deltaGrownStalkPerSeason: BigInt!
  deltaConvertDownPenalty: BigDecimal
  deltaActiveFarmers: Int!

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!

  # caseId is unique to hourly snapshot
  "[Seed Gauge] The caseId used in the seasonal adjustment of beanToMaxLpGpPerBdvRatio"
  caseId: BigInt
}

type SiloDailySnapshot @entity {
  "ID of silo - Day"
  id: ID!
  "Last season for the snapshot"
  season: Int!
  "Silo associated with the snapshot"
  silo: Silo!
  "Point in time current stalk balance"
  stalk: BigInt!
  "Point in time current BDV of all deposited assets"
  depositedBDV: BigInt!
  "Point in time total of beans that have been Planted"
  plantedBeans: BigInt!
  "Point in time current roots balance"
  roots: BigInt!
  "[Seed Gauge] Stalk that is currently Germinating"
  germinatingStalk: BigInt!
  "Point in time total stalk that has been penalized by the convert down penalty"
  penalizedStalkConvertDown: BigInt!
  "Point in time totalstalk that was not penalized during the application of a down convert penalty"
  unpenalizedStalkConvertDown: BigInt!
  "Average convert down penalty that has been assessed, in percent. 20.5 = 20.5%"
  avgConvertDownPenalty: BigDecimal!
  "Point in time total grown stalk gained via the Convert Up Bonus"
  bonusStalkConvertUp: BigInt!
  "Point in time total BDV converted up that was awarded the bonus"
  totalBdvConvertUpBonus: BigInt!
  "Point in time total BDV converted up regardless of receiving a bonus. (!) This value accumulates only when the Convert Up Bonus (gauge id 2) is active."
  totalBdvConvertUp: BigInt!

  "Point in time cumulative total for bean mints sent to the silo"
  beanMints: BigInt!
  "Point in time current plantable stalk for bean seigniorage not yet claimed (only set on protocol-level Silo)"
  plantableStalk: BigInt!
  "[Seed Gauge] Current target ratio of Bean to LP deposits"
  beanToMaxLpGpPerBdvRatio: BigInt!
  "Point in time average grown stalk per bdv per season"
  avgGrownStalkPerBdvPerSeason: BigInt!
  "Point in time grown stalk per season"
  grownStalkPerSeason: BigInt!
  "Point in time PI-7 convert down penalty)"
  convertDownPenalty: BigDecimal
  "Point in time active farmers"
  activeFarmers: Int!

  deltaStalk: BigInt!
  deltaDepositedBDV: BigInt!
  deltaPlantedBeans: BigInt!
  deltaRoots: BigInt!
  deltaGerminatingStalk: BigInt!
  deltaPenalizedStalkConvertDown: BigInt!
  deltaUnpenalizedStalkConvertDown: BigInt!
  deltaAvgConvertDownPenalty: BigDecimal!
  deltaBonusStalkConvertUp: BigInt!
  deltaTotalBdvConvertUpBonus: BigInt!
  deltaTotalBdvConvertUp: BigInt!
  deltaBeanMints: BigInt!
  deltaPlantableStalk: BigInt!
  deltaBeanToMaxLpGpPerBdvRatio: BigInt!
  deltaAvgGrownStalkPerBdvPerSeason: BigInt!
  deltaGrownStalkPerSeason: BigInt!
  deltaConvertDownPenalty: BigDecimal
  deltaActiveFarmers: Int!

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type SiloAsset @entity {
  "Silo ID - Asset Token Address"
  id: ID!
  "Silo for this asset"
  silo: Silo!
  "Token address for this asset"
  token: Bytes!
  "Current Token amount of deposits"
  depositedAmount: BigInt!
  "Current BDV of deposits"
  depositedBDV: BigInt!
  "Current Token amount of silo withdrawals"
  withdrawnAmount: BigInt!

  "Season when the previous hourly snapshot was taken/updated"
  lastHourlySnapshotSeason: Int
  "Day of when the previous daily snapshot was taken/updated"
  lastDailySnapshotDay: BigInt
  "Link to hourly snapshot data"
  hourlySnapshots: [SiloAssetHourlySnapshot!]! @derivedFrom(field: "siloAsset")
  "Link to daily snapshot data"
  dailySnapshots: [SiloAssetDailySnapshot!]! @derivedFrom(field: "siloAsset")
}

type SiloAssetHourlySnapshot @entity {
  "Silo Asset ID - Season"
  id: ID!
  "Season for the snapshot"
  season: Int!
  "Silo asset associated with this snapshot"
  siloAsset: SiloAsset!
  "Point in time current BDV of deposits"
  depositedBDV: BigInt!
  "Point in time current Token amount of deposits"
  depositedAmount: BigInt!
  "Point in time current Token amount of silo withdrawals"
  withdrawnAmount: BigInt!

  deltaDepositedBDV: BigInt!
  deltaDepositedAmount: BigInt!
  deltaWithdrawnAmount: BigInt!

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type SiloAssetDailySnapshot @entity {
  "Silo Asset ID - Day"
  id: ID!
  "Last season for the snapshot"
  season: Int!
  "Silo asset associated with this snapshot"
  siloAsset: SiloAsset!
  "Point in time current BDV of deposits"
  depositedBDV: BigInt!
  "Point in time current Token amount of deposits"
  depositedAmount: BigInt!
  "Point in time current Token amount of silo withdrawals"
  withdrawnAmount: BigInt!

  deltaDepositedBDV: BigInt!
  deltaDepositedAmount: BigInt!
  deltaWithdrawnAmount: BigInt!

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

# At the beginning of each season, initiate one of these for the following season and complete the one for the current season.
# Results for the current season are then added to cumulative entity.
type MarketPerformanceSeasonal @entity {
  "Silo ID - Season"
  id: ID!
  season: Int!
  silo: Silo!

  "True if the entity is valid; entity is not valid for (current season + 1), the 'this' season has not occurred yet"
  valid: Boolean!
  "Timestamp of this entry becoming valid"
  timestamp: BigInt

  "Amount of tokens in each well, as of the previous season starting. Ordering according to silo.whitelistedTokens"
  prevSeasonTokenBalances: [BigInt!]!
  "Prices of the non-bean token in each well, as of the previous season starting. Ordering according to silo.whitelistedTokens"
  prevSeasonTokenUsdPrices: [BigDecimal!]!
  "Usd value of the non-bean tokens in each well, as of the previous season starting. Ordering according to silo.whitelistedTokens"
  prevSeasonTokenUsdValues: [BigDecimal!]!
  "Usd value across all the non-bean tokens in each well, as of the previous season starting"
  prevSeasonTotalUsd: BigDecimal!

  # Does not store the token balances as of this season starting; is not relevant to the calculation of price changes.

  "Prices of the non-bean token in each well, as of this season starting. Ordering according to silo.whitelistedTokens. Null for !valid"
  thisSeasonTokenUsdPrices: [BigDecimal!]
  "Usd value of prevSeasonTokenBalances, as of this season starting. Ordering according to silo.whitelistedTokens. Null for !valid"
  thisSeasonTokenUsdValues: [BigDecimal!]
  "Usd value across all prevSeasonTokenBalances, as of this season starting. Null for !valid"
  thisSeasonTotalUsd: BigDecimal

  "Seasonal net change in usd value of each deposited non-bean token. Ordering according to silo.whitelistedTokens. Null for !valid"
  usdChange: [BigDecimal!]
  "Seasonal net change in usd value across all deposited non-bean tokens. Null for !valid"
  totalUsdChange: BigDecimal
  "Seasonal percentage change in value of each deposited non-bean token. Ordering according to silo.whitelistedTokens. Null for !valid"
  percentChange: [BigDecimal!]
  "Seasonal percentage change in value across all deposited non-bean tokens. Null for !valid"
  totalPercentChange: BigDecimal

  "Cumulative net change in usd value of each deposited non-bean token. Ordering according to silo.whitelistedTokens"
  cumulativeUsdChange: [BigDecimal!]
  "Cumulative net change in usd value across all deposited non-bean tokens"
  cumulativeTotalUsdChange: BigDecimal
  "Cumulative percentage change in value of each deposited non-bean token. It is possible for this value to appear out of sync with cumulativeUsdChange; it does not account for the number of these tokens deposited at the time of the value changing (only their ratios). Ordering according to silo.whitelistedTokens"
  cumulativePercentChange: [BigDecimal!]
  "Cumulative percentage change in value across all deposited non-bean tokens. It is possible for this value to appear out of sync with cumulativeUsdChange; it does not account for the number of these tokens deposited at the time of the value changing (only their ratios)"
  cumulativeTotalPercentChange: BigDecimal
}

type WrappedDepositERC20 @entity {
  "Address of the wrapped silo token"
  id: Bytes!
  "'beanstalk'"
  beanstalk: Beanstalk!
  "Silo stats for this wrapped deposit contract"
  silo: Silo!
  "Number of decimals for the token"
  decimals: Int!
  "The whitelisted silo deposit token that this erc20 is wrapping"
  underlyingAsset: WhitelistTokenSetting!

  "Total token supply"
  supply: BigInt!
  "Amount of underlying tokens redeemable for 1e(decimals) of this wrapped token"
  redeemRate: BigInt!

  "Projected apy from percent change in redeem rate over the past 24h"
  apy24h: BigDecimal
  "Projected apy from percent change in redeem rate over the past 7d"
  apy7d: BigDecimal
  "Projected apy from percent change in redeem rate over the past 30d"
  apy30d: BigDecimal
  "Projected apy from percent change in redeem rate over the past 90d"
  apy90d: BigDecimal

  "Season when the previous hourly snapshot was taken/updated"
  lastHourlySnapshotSeason: Int
  "Day of when the previous daily snapshot was taken/updated"
  lastDailySnapshotDay: BigInt
  "Link to hourly snapshot data"
  hourlySnapshots: [WrappedDepositERC20HourlySnapshot!]! @derivedFrom(field: "token")
  "Link to daily snapshot data"
  dailySnapshots: [WrappedDepositERC20DailySnapshot!]! @derivedFrom(field: "token")
}

type WrappedDepositERC20HourlySnapshot @entity {
  "Token address - Season"
  id: ID!
  "The season for this snapshot"
  season: Int!
  "WrappedDepositERC20 associated with this snapshot"
  token: WrappedDepositERC20!
  "Hourly Silo stats for this wrapped deposit contract"
  siloHourlySnapshot: SiloHourlySnapshot!

  "Total token supply"
  supply: BigInt!
  "Amount of underlying tokens redeemable for 1e(decimals) of this wrapped token"
  redeemRate: BigInt!

  "Delta of supply"
  deltaSupply: BigInt!
  "Delta of redeemRate"
  deltaRedeemRate: BigInt!

  "Projected apy from percent change in redeem rate over the past 24h"
  apy24h: BigDecimal
  "Projected apy from percent change in redeem rate over the past 7d"
  apy7d: BigDecimal
  "Projected apy from percent change in redeem rate over the past 30d"
  apy30d: BigDecimal
  "Projected apy from percent change in redeem rate over the past 90d"
  apy90d: BigDecimal

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type WrappedDepositERC20DailySnapshot @entity {
  "Token address - Day"
  id: ID!
  "The season for this snapshot"
  season: Int!
  "WrappedDepositERC20 associated with this snapshot"
  token: WrappedDepositERC20!
  "Daily Silo stats for this wrapped deposit contract"
  siloDailySnapshot: SiloHourlySnapshot!

  "Total token supply"
  supply: BigInt!
  "Amount of underlying tokens redeemable for 1e(decimals) of this wrapped token"
  redeemRate: BigInt!

  "Delta of supply"
  deltaSupply: BigInt!
  "Delta of redeemRate"
  deltaRedeemRate: BigInt!

  "Projected apy from percent change in redeem rate over the past 24h"
  apy24h: BigDecimal
  "Projected apy from percent change in redeem rate over the past 7d"
  apy7d: BigDecimal
  "Projected apy from percent change in redeem rate over the past 30d"
  apy30d: BigDecimal
  "Projected apy from percent change in redeem rate over the past 90d"
  apy90d: BigDecimal

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type SiloYield @entity {
  "Season of data points - EMA window"
  id: ID!
  "Sortable int field for season"
  season: Int!
  "Window used for vAPY calc"
  emaWindow: EmaWindow!
  "Beta used for EMA"
  beta: BigDecimal!
  "u used for EMA"
  u: Int!
  "Bean EMA for season"
  beansPerSeasonEMA: BigDecimal!
  "Current whitelisted silo tokens"
  whitelistedTokens: [Bytes!]!
  "Current Bean (0) and Stalk (1) APY for each token."
  tokenAPYS: [TokenYield!]! @derivedFrom(field: "siloYield")
  "Unix timestamp of update"
  createdAt: BigInt!
}

type TokenYield @entity {
  "Token address - season - EMA window"
  id: Bytes!
  "Token being calculated"
  token: Bytes!
  "Season for APY calculation"
  season: Int!
  "Related silo yield entity"
  siloYield: SiloYield!
  "Bean APY for season"
  beanAPY: BigDecimal!
  "Stalk APY for season"
  stalkAPY: BigDecimal!
  "Unix timestamp of update"
  createdAt: BigInt!
}

type WhitelistTokenSetting @entity {
  "Contract address for the whitelisted token"
  id: Bytes!
  "Encoded BDV selector"
  selector: Bytes!
  "Represents how much Stalk one BDV of the underlying deposited token grows each season."
  stalkEarnedPerSeason: BigInt!
  "The stalk per BDV that the silo grants in exchange for depositing this token."
  stalkIssuedPerBdv: BigInt!
  "The stem tip of the whitelisted token. Used to derive cumulative Stalk growth. "
  stemTip: BigInt!
  "The last season in which the stalkEarnedPerSeason for this token was updated."
  milestoneSeason: Int!
  "Whether the seed gauge is enabled on this whitelisted token"
  isGaugeEnabled: Boolean!
  "[Seed Gauge] Current Gauge Points"
  gaugePoints: BigInt
  "[Seed Gauge] The current optimal targeted distribution of BDV for this whitelisted asset"
  optimalPercentDepositedBdv: BigInt
  "Last timestamp entity was updated"
  updatedAt: BigInt!
  "Season when the previous hourly snapshot was taken/updated"
  lastHourlySnapshotSeason: Int
  "Day of when the previous daily snapshot was taken/updated"
  lastDailySnapshotDay: BigInt
  "Link to hourly snapshot data"
  hourlySnapshots: [WhitelistTokenHourlySnapshot!]! @derivedFrom(field: "token")
  "Link to daily snapshot data"
  dailySnapshots: [WhitelistTokenDailySnapshot!]! @derivedFrom(field: "token")

  # Unique to the main entity, not on dailySnapshots
  "Number of decimals in this token"
  decimals: Int!
}

type WhitelistTokenHourlySnapshot @entity {
  "Token address - Season"
  id: ID!
  "The season for this snapshot"
  season: Int!
  "WhitelistTokenSetting associated with this snapshot"
  token: WhitelistTokenSetting!
  "Encoded BDV selector"
  selector: Bytes!
  "Represents how much Stalk one BDV of the underlying deposited token grows each season."
  stalkEarnedPerSeason: BigInt!
  "The stalk per BDV that the silo grants in exchange for depositing this token."
  stalkIssuedPerBdv: BigInt!
  "The stem tip of the whitelisted token. Used to derive cumulative Stalk growth. "
  stemTip: BigInt!
  "The last season in which the stalkEarnedPerSeason for this token was updated."
  milestoneSeason: Int!
  "Whether the seed gauge is enabled on this whitelisted token"
  isGaugeEnabled: Boolean!
  "[Seed Gauge] Current Gauge Points"
  gaugePoints: BigInt
  "[Seed Gauge] The current optimal targeted distribution of BDV for this whitelisted asset"
  optimalPercentDepositedBdv: BigInt

  deltaStalkEarnedPerSeason: BigInt!
  deltaStalkIssuedPerBdv: BigInt!
  deltaStemTip: BigInt!
  deltaMilestoneSeason: Int!
  deltaIsGaugeEnabled: Boolean!
  deltaGaugePoints: BigInt
  deltaOptimalPercentDepositedBdv: BigInt

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!

  # These are unique to the snapshot, and not on the main entity
  "Point in time hourly bdv"
  bdv: BigInt
  deltaBdv: BigInt
}

type WhitelistTokenDailySnapshot @entity {
  "Token address - Day"
  id: ID!
  "The season for this snapshot"
  season: Int!
  "WhitelistTokenSetting associated with this snapshot"
  token: WhitelistTokenSetting!
  "Encoded BDV selector"
  selector: Bytes!
  "Represents how much Stalk one BDV of the underlying deposited token grows each season."
  stalkEarnedPerSeason: BigInt!
  "The stalk per BDV that the silo grants in exchange for depositing this token."
  stalkIssuedPerBdv: BigInt!
  "The stem tip of the whitelisted token. Used to derive cumulative Stalk growth. "
  stemTip: BigInt!
  "The last season in which the stalkEarnedPerSeason for this token was updated."
  milestoneSeason: Int!
  "Whether the seed gauge is enabled on this whitelisted token"
  isGaugeEnabled: Boolean!
  "[Seed Gauge] Current Gauge Points"
  gaugePoints: BigInt
  "[Seed Gauge] The current optimal targeted distribution of BDV for this whitelisted asset"
  optimalPercentDepositedBdv: BigInt

  deltaStalkEarnedPerSeason: BigInt!
  deltaStalkIssuedPerBdv: BigInt!
  deltaStemTip: BigInt!
  deltaMilestoneSeason: Int!
  deltaIsGaugeEnabled: Boolean!
  deltaGaugePoints: BigInt
  deltaOptimalPercentDepositedBdv: BigInt

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!

  # These are unique to the snapshot, and not on the main entity
  "Point in time daily bdv"
  bdv: BigInt
  deltaBdv: BigInt
}

type Field @entity {
  "Contract address for this field or farmer"
  id: Bytes!
  "'beanstalk'"
  beanstalk: Beanstalk!
  "Numeric identifier of the field emitted on protocol events"
  fieldId: BigInt!
  "Farmer address if applicable"
  farmer: Farmer
  "Current season number"
  season: Int!
  "Current temperature, in percent (i.e. 50.5 = 50.5% temperature)"
  temperature: BigDecimal!
  "PI-6 Cultivation Factor, in percent (i.e. 20.5 = 20.5% cultivation factor)"
  cultivationFactor: BigDecimal
  "PI-10 Cultivation Temperature, in percent (i.e. 50.5 = 50.5% cultivation temperature). This value is presented since protocol deployment, despite not being introduced onchain until PI-10."
  cultivationTemperature: BigDecimal
  "Rate of return: Temperature / Bean Price"
  realRateOfReturn: BigDecimal!
  "Cumulative number of unique sowers"
  numberOfSowers: Int!
  "Cumulative number of sows"
  numberOfSows: Int!
  "Cumulative total of sown beans"
  sownBeans: BigInt!
  "Array of current non-harvestable plots"
  plotIndexes: [BigInt!]!
  "Current outstanding non-harvestable pods"
  unharvestablePods: BigInt!
  "Current harvestable pods"
  harvestablePods: BigInt!
  "Cumulative harvested pods"
  harvestedPods: BigInt!
  "Pods from L1 which has not been minted on L2 yet"
  unmigratedL1Pods: BigInt
  "Current amount of soil available"
  soil: BigInt!
  "Current pod index"
  podIndex: BigInt!
  "Current harvestable index"
  harvestableIndex: BigInt!
  "Current pod rate: Total unharvestable pods / bean supply"
  podRate: BigDecimal!
  "Season when the previous hourly snapshot was taken/updated"
  lastHourlySnapshotSeason: Int
  "Day of when the previous daily snapshot was taken/updated"
  lastDailySnapshotDay: BigInt
  "Link to hourly snapshot data"
  hourlySnapshots: [FieldHourlySnapshot!]! @derivedFrom(field: "field")
  "Link to daily snapshot data"
  dailySnapshots: [FieldDailySnapshot!]! @derivedFrom(field: "field")
}

type FieldHourlySnapshot @entity {
  "Field ID - Season"
  id: ID!
  "Field associated with this snapshot"
  field: Field!
  "Numeric identifier of the field"
  fieldId: BigInt!
  "Season"
  season: Int!
  "Point in time temperature"
  temperature: BigDecimal!
  "Point in time PI-6 Cultivation Factor"
  cultivationFactor: BigDecimal
  "Point in time PI-10 Cultivation Temperature"
  cultivationTemperature: BigDecimal
  "Point in time rate of return: Temperature / Bean Price"
  realRateOfReturn: BigDecimal!
  "Point in time cumulative number of unique sowers"
  numberOfSowers: Int!
  "Point in time cumulative number of sows"
  numberOfSows: Int!
  "Point in time cumulative total of sown beans"
  sownBeans: BigInt!
  "Point in time outstanding non-harvestable pods"
  unharvestablePods: BigInt!
  "Point in time harvestable pods"
  harvestablePods: BigInt!
  "Point in time cumulative harvested pods"
  harvestedPods: BigInt!
  "Point in time amount of soil remaining"
  soil: BigInt!
  "Point in time amount of soil issued"
  issuedSoil: BigInt!
  "Point in time pod index"
  podIndex: BigInt!
  "Point in time harvestable index"
  harvestableIndex: BigInt!
  "Point in time pod rate: Total unharvestable pods / bean supply"
  podRate: BigDecimal!

  deltaTemperature: BigDecimal!
  deltaCultivationFactor: BigDecimal
  deltaCultivationTemperature: BigDecimal
  deltaRealRateOfReturn: BigDecimal!
  deltaNumberOfSowers: Int!
  deltaNumberOfSows: Int!
  deltaSownBeans: BigInt!
  deltaUnharvestablePods: BigInt!
  deltaHarvestablePods: BigInt!
  deltaHarvestedPods: BigInt!
  deltaSoil: BigInt!
  deltaIssuedSoil: BigInt!
  deltaPodIndex: BigInt!
  deltaHarvestableIndex: BigInt!
  deltaPodRate: BigDecimal!

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!

  # These are unique to hourly snapshot
  "The caseId used in the seasonal adjustment of temperature"
  caseId: BigInt
  "Block that started this season/at time of snapshot creation"
  seasonBlock: BigInt!
  "Number of blocks between sunrise and soil being sold out"
  blocksToSoldOutSoil: BigInt
  "Bool flag if soil sold out for the season"
  soilSoldOut: Boolean!
  "Result of getDeltaPodDemand for this season. Refer to protocol codebase to understand how to interpret this value"
  deltaPodDemand: BigInt!
}

type FieldDailySnapshot @entity {
  "Field ID - Day"
  id: ID!
  "Field associated with this snapshot"
  field: Field!
  "Numeric identifier of the field"
  fieldId: BigInt!
  "Last season in the snapshot"
  season: Int!
  "Point in time temperature"
  temperature: BigDecimal!
  "Point in time PI-6 Cultivation Factor"
  cultivationFactor: BigDecimal
  "Point in time PI-10 Cultivation Temperature"
  cultivationTemperature: BigDecimal
  "Point in time rate of return: Temperature / Bean Price"
  realRateOfReturn: BigDecimal!
  "Point in time cumulative number of unique sowers"
  numberOfSowers: Int!
  "Point in time cumulative number of sows"
  numberOfSows: Int!
  "Point in time cumulative total of sown beans"
  sownBeans: BigInt!
  "Point in time outstanding non-harvestable pods"
  unharvestablePods: BigInt!
  "Point in time harvestable pods"
  harvestablePods: BigInt!
  "Point in time delta harvested pods"
  harvestedPods: BigInt!
  "Point in time amount of soil remaining"
  soil: BigInt!
  "Point in time amount of soil issued"
  issuedSoil: BigInt!
  "Point in time pod index"
  podIndex: BigInt!
  "Point in time harvestable index"
  harvestableIndex: BigInt!
  "Point in time pod rate: Total unharvestable pods / bean supply"
  podRate: BigDecimal!

  deltaTemperature: BigDecimal!
  deltaCultivationFactor: BigDecimal
  deltaCultivationTemperature: BigDecimal
  deltaRealRateOfReturn: BigDecimal!
  deltaNumberOfSowers: Int!
  deltaNumberOfSows: Int!
  deltaSownBeans: BigInt!
  deltaUnharvestablePods: BigInt!
  deltaHarvestablePods: BigInt!
  deltaHarvestedPods: BigInt!
  deltaSoil: BigInt!
  deltaIssuedSoil: BigInt!
  deltaPodIndex: BigInt!
  deltaHarvestableIndex: BigInt!
  deltaPodRate: BigDecimal!

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

# ---===== Farmer Account Entities =====---

type Farmer @entity {
  "Address for the farmer"
  id: Bytes!
  "Block number in which this entity was created"
  creationBlock: BigInt!
  silo: Silo @derivedFrom(field: "farmer")
  deposits: [SiloDeposit!]! @derivedFrom(field: "farmer")
  withdraws: [SiloWithdraw!]! @derivedFrom(field: "farmer")
  field: Field @derivedFrom(field: "farmer")
  plots: [Plot!]! @derivedFrom(field: "farmer")
  listings: [PodListing!]! @derivedFrom(field: "farmer")
  orders: [PodOrder!]! @derivedFrom(field: "farmer")
  fills: [PodFill!]! @derivedFrom(field: "toFarmer")
  fertilizers: [FertilizerBalance!]! @derivedFrom(field: "farmer")
}

type SiloDeposit @entity {
  """
  Account - Token Address - Deposit Version - (Season|Stem)
  """
  id: ID!
  "Farmer address"
  farmer: Farmer!
  "Token Address"
  token: Bytes!
  "Version of deposit. Options are season, v3, v3.1. `season` type includes those deposits which are calculated according to their silo v1 deposits pre-explout"
  depositVersion: String!
  "Season of deposit"
  season: Int
  "Stem of deposit"
  stem: BigInt
  "Silo v3.1 equivalent stem. This value will always be assigned regardless of the deposit version."
  stemV31: BigInt!
  "Token amount deposited"
  depositedAmount: BigInt!
  "Original deposited BDV"
  depositedBDV: BigInt!
  "Transaction hashes pertaining to this deposit"
  hashes: [Bytes!]!
  "Block of first deposit"
  createdBlock: BigInt!
  "Block when last updated"
  updatedBlock: BigInt!
  "Timestamp of first deposit"
  createdAt: BigInt!
  "Timestamp when last updated"
  updatedAt: BigInt!
}

type SiloWithdraw @entity {
  "Account - Deposit Token - Current Season"
  id: ID!
  "Farmer address"
  farmer: Farmer!
  "Token address"
  token: Bytes!
  "Season withdrawal initiated"
  withdrawSeason: Int!
  "Season when withdrawal can be claimed"
  claimableSeason: Int!
  "Flag for if this has been claimed"
  claimed: Boolean!
  "Token amount withdrawn"
  amount: BigInt!
  "Timestamp created"
  createdAt: BigInt!
}

type Plot @entity {
  "Plot index"
  id: ID!
  "Field to which this plot belongs"
  field: Field!
  "Numeric identifier of the field"
  fieldId: BigInt!
  "Farmer who owns this plot"
  farmer: Farmer!
  "Source for this plot"
  source: PlotSource!
  "Transaction hash corresponding to when source was set. Not the same as creationHash which can include plots splitting from transfer or harvest without the owner changing"
  sourceHash: Bytes!
  "If `source === 'TRANSFER'`: Source SOW/MARKET of the farmer who acquired the plot. Cannot be TRANSFER."
  preTransferSource: PlotSource
  "If `source === 'TRANSFER'`: Farmer who acquired this plot in the Field or Market, and spent `beansPerPod` for each pod in the plot."
  preTransferOwner: Farmer
  "Associated plot listing"
  listing: PodListing
  "Plot Index"
  index: BigInt!
  "Total pods in plot"
  pods: BigInt!

  "Number of beans spent for each pod, whether through sowing or on the marketplace"
  beansPerPod: BigInt!
  "Same as beansPerPod, but only for the initial sowing"
  sownBeansPerPod: BigInt!
  "The harvestable index at the time the plot was sown or exchanged on the marketplace"
  initialHarvestableIndex: BigInt!
  "Same as initialHarvestableIndex, but only for the initial sowing"
  sownInitialHarvestableIndex: BigInt!

  "Number of pods harvestable"
  harvestablePods: BigInt!
  "Number of pods harvested"
  harvestedPods: BigInt!
  "Flag for if plot is fully harvested"
  fullyHarvested: Boolean!
  "Timestamp of plot harvest, if it has harvested"
  harvestAt: BigInt
  "Transaction hash of plot harvest"
  harvestHash: Bytes

  "Season on entity creation (not sown)"
  season: Int!
  "Transaction hash of when this plot entity was created (not sown)"
  creationHash: Bytes!
  "Timestamp of entity creation (not sown)"
  createdAt: BigInt!

  "Same as season, but only for the initial sowing"
  sowSeason: Int!
  "Transaction hash of initial sowing"
  sowHash: Bytes!
  "Timestamp of initial sowing"
  sowTimestamp: BigInt!

  "Timestamp when updated"
  updatedAt: BigInt!
  "Block when updated"
  updatedAtBlock: BigInt!
}

type PodMarketplace @entity {
  "Field id"
  id: ID!
  "Current season of the marketplace"
  season: Int!
  "Numeric identifier of the field this marketplace tracks"
  fieldId: BigInt!
  "Information about the active pod listings. Each entry of the form 'account-index-expiry'"
  activeListings: [String!]!
  "Information about the active pod orders. Each entry of the form 'orderId-maxPlaceInLine'"
  activeOrders: [String!]!
  "All historical listings"
  allListings: [PodListing!]! @derivedFrom(field: "podMarketplace")
  "All historical orders"
  allOrders: [PodOrder!]! @derivedFrom(field: "podMarketplace")
  "All historical marketplace fills"
  fills: [PodFill!]! @derivedFrom(field: "podMarketplace")
  "Current cumulative pods listed for sale"
  listedPods: BigInt!
  "Current amount of total pods listed"
  availableListedPods: BigInt!
  "Current cumulative pod listings filled"
  filledListedPods: BigInt!
  "Current cumulative pod listings that expired"
  expiredListedPods: BigInt!
  "Current cumulative pod listings that were cancelled"
  cancelledListedPods: BigInt!
  "Current cumulative beans in pod orders created"
  orderBeans: BigInt!
  "Current amount of total beans in pod orders"
  availableOrderBeans: BigInt!
  "Current cumulative filled beans in pod orders"
  filledOrderBeans: BigInt!
  "Current cumulative pod orders filled"
  filledOrderedPods: BigInt!
  "Current cumulative beans in pod orders cancelled"
  cancelledOrderBeans: BigInt!
  "Cumulative pod volume between listings and orders"
  podVolume: BigInt!
  "Cumulative bean volume between listings and orders"
  beanVolume: BigInt!
  "Season when the previous hourly snapshot was taken/updated"
  lastHourlySnapshotSeason: Int
  "Day of when the previous daily snapshot was taken/updated"
  lastDailySnapshotDay: BigInt
  "Link to hourly snapshot data"
  hourlySnapshots: [PodMarketplaceHourlySnapshot!]! @derivedFrom(field: "podMarketplace")
  "Link to daily snapshot data"
  dailySnapshots: [PodMarketplaceDailySnapshot!]! @derivedFrom(field: "podMarketplace")
}

type PodMarketplaceHourlySnapshot @entity {
  "Marketplace ID - Season"
  id: ID!
  "Point in time latest season"
  season: Int!
  "Marketplace associated with snapshot"
  podMarketplace: PodMarketplace!
  "Numeric identifier of the field"
  fieldId: BigInt!
  "Point in time current cumulative pods listed for sale"
  listedPods: BigInt!
  "Point in time current amount of total pods listed"
  availableListedPods: BigInt!
  "Point in time current cumulative pod listings filled"
  filledListedPods: BigInt!
  "Point in time current cumulative pod listings that expired"
  expiredListedPods: BigInt!
  "Point in time current cumulative pod listings that were cancelled"
  cancelledListedPods: BigInt!
  "Current cumulative beans in pod orders created"
  orderBeans: BigInt!
  "Current amount of total beans in pod orders"
  availableOrderBeans: BigInt!
  "Current cumulative filled beans in pod orders"
  filledOrderBeans: BigInt!
  "Current cumulative pod orders filled"
  filledOrderedPods: BigInt!
  "Current cumulative beans in pod orders cancelled"
  cancelledOrderBeans: BigInt!
  "Point in time current cumulative pod volume between listings and orders"
  podVolume: BigInt!
  "Point in time current cumulative bean volume between listings and orders"
  beanVolume: BigInt!

  deltaListedPods: BigInt!
  deltaAvailableListedPods: BigInt!
  deltaFilledListedPods: BigInt!
  deltaExpiredListedPods: BigInt!
  deltaCancelledListedPods: BigInt!
  deltaOrderBeans: BigInt!
  deltaAvailableOrderBeans: BigInt!
  deltaFilledOrderBeans: BigInt!
  deltaFilledOrderedPods: BigInt!
  deltaCancelledOrderBeans: BigInt!
  deltaPodVolume: BigInt!
  deltaBeanVolume: BigInt!

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type PodMarketplaceDailySnapshot @entity {
  "Marketplace ID - Day"
  id: ID!
  "Point in time latest season"
  season: Int!
  "Marketplace associated with snapshot"
  podMarketplace: PodMarketplace!
  "Numeric identifier of the field"
  fieldId: BigInt!
  "Point in time current cumulative pods listed for sale"
  listedPods: BigInt!
  "Point in time current amount of total pods listed"
  availableListedPods: BigInt!
  "Point in time current cumulative pod listings filled"
  filledListedPods: BigInt!
  "Point in time current cumulative pod listings that expired"
  expiredListedPods: BigInt!
  "Point in time current cumulative pod listings that were cancelled"
  cancelledListedPods: BigInt!
  "Current cumulative beans in pod orders created"
  orderBeans: BigInt!
  "Current amount of total beans in pod orders"
  availableOrderBeans: BigInt!
  "Current cumulative filled beans in pod orders"
  filledOrderBeans: BigInt!
  "Current cumulative pod orders filled"
  filledOrderedPods: BigInt!
  "Current cumulative beans in pod orders cancelled"
  cancelledOrderBeans: BigInt!
  "Point in time current cumulative pod volume between listings and orders"
  podVolume: BigInt!
  "Point in time current cumulative bean volume between listings and orders"
  beanVolume: BigInt!

  deltaListedPods: BigInt!
  deltaAvailableListedPods: BigInt!
  deltaFilledListedPods: BigInt!
  deltaExpiredListedPods: BigInt!
  deltaCancelledListedPods: BigInt!
  deltaOrderBeans: BigInt!
  deltaAvailableOrderBeans: BigInt!
  deltaFilledOrderBeans: BigInt!
  deltaFilledOrderedPods: BigInt!
  deltaCancelledOrderBeans: BigInt!
  deltaPodVolume: BigInt!
  deltaBeanVolume: BigInt!

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type PodListing @entity {
  ######################## Identifiers ########################

  """
  The PodListing ID is a unique subgraph ID: `{account}-{index}"

  The on-chain identifier for a PodListing is the `index`.
  """
  id: ID!

  "Numeric identifier of the field for this listing"
  fieldId: BigInt!
  "Marketplace used for listing"
  podMarketplace: PodMarketplace!

  "Historical ID for joins"
  historyID: String!

  "Plot being Listed."
  plot: Plot!

  "The Farmer that created the PodListing."
  farmer: Farmer!

  ######################## Configuration ########################

  """
  The absolute index of the listed Plot in the Pod Line.

  Measured from the front, so the Listing contains all Pods between
  (index) and (index + totalAmount).

  An example where the podLine is 50,000 but the index is 150,000:
     0         the first Pod issued
     100,000   harvestableIndex
     150,000   index
  """
  index: BigInt!

  """
  The position within the Plot from which to sell Pods.

  0 <= `start` <= (plot size - `amount`)
  """
  start: BigInt!

  "Where Beans are sent when the PodListing is Filled. See `FarmToMode`."
  mode: Int!

  ######################## Constraints ########################

  """
  When the `harvestableIndex` reaches this number, the Listing becomes EXPIRED.
  """
  maxHarvestableIndex: BigInt!

  "Minimum number of Beans required to perform a Fill."
  minFillAmount: BigInt!

  ######################## Pricing ########################

  """
  The Pricing Type states whether this PodListing uses FIXED or DYNAMIC pricing.

  null = V1 FIXED  = use `pricePerPod`
  0    = V2 FIXED  = use `pricePerPod`
  1    = V2 DYNAMIC = use `pricingFunction`
  """
  pricingType: Int

  """
  [V1] The FIXED price per Pod denominated in Beans.

  Ex. `pricePerPod = 10000` indicates a price of 0.01 Beans per Pod.

  If `pricingType = 1`, this field is set to `0` and should be ignored.
  """
  pricePerPod: Int!

  """
  [V2] The FIXED or DYNAMIC pricing function, encoded as bytes.

  This must be decoded client-side, see `LibPolynomial.sol` for more info.
  """
  pricingFunction: Bytes

  ######################## Amounts [Relative to Original] ########################

  """
  The original index from the first emission of PodListingCreated in a chain.

  If `originalIndex !== index`, then this PodListing was created when a parent
  PodListing was partially filled.
  """
  originalIndex: BigInt!

  "The place of this plot in the pod line at the time it was listed"
  originalPlaceInLine: BigInt!

  """
  The total number of Pods listed during the first emission of PodListingCreated.
  """
  originalAmount: BigInt!

  """
  The amount of Pods Filled since the initial PodListing was Created.

  `0 <= filled <= originalAmount`
  """
  filled: BigInt!

  ######################## Amounts [Relative to Child] ########################

  """
  The maximum amount of Pods remaining to be sold by *this* PodListing.

  When this PodListing is Filled or Cancelled, `amount` does NOT change.
  """
  amount: BigInt!

  """
  The number of Pods remaining in *this* PodListing.

  When a Fill occurs, `remainingAmount` is decremented on this PodListing. A new
  PodListing is created with an updated `index` and `amount` equal to this
  PodListing's remainingAmount.

  If this PodListing has NOT been Filled: `remainingAmount = amount`
  If this PodListing has been Filled: `remainingAmount < amount`
  If this PodListing has been Cancelled: `remainingAmount = 0`
  """
  remainingAmount: BigInt!

  """
  The number of Pods purchased from *this* PodListing.

  If not yet Filled or the PodListing is CANCELLED: `filledAmount = 0`
  """
  filledAmount: BigInt!

  ######################## Activity ########################

  "Any Fills associated with this PodListing."
  fill: PodFill

  ######################## Metadata ########################

  "Current market status of listing"
  status: MarketStatus!

  "Timestamp of PodListing creation."
  createdAt: BigInt!

  "Timestamp of last update to this PodListing, including Fills and Cancellations."
  updatedAt: BigInt!

  "Transaction hash when this PodListing entity was created."
  creationHash: Bytes!
}

type PodOrder @entity {
  ######################## Identifiers ########################

  """
  The PodOrder ID matchces the `id` stored on-chain:

  `keccak256(abi.encodePacked(account, pricePerPod, maxPlaceInLine, minFillAmount))`
  """
  id: ID!

  """
  Historical ID for joins: `{account}-{createdAt}`
  """
  historyID: String!

  "The Farmer that created the Pod Order."
  farmer: Farmer!

  "Numeric identifier of the field for this order"
  fieldId: BigInt!
  "Marketplace used for Pod Order."
  podMarketplace: PodMarketplace!

  ######################## Constraints ########################

  """
  The Farmer is willing to buy any Pod that is before maxPlaceInLine at pricePerPod.
  As the Pod Line moves, this value stays the same because new Pods meet the criteria.
  """
  maxPlaceInLine: BigInt!

  "Minimum number of Pods required to perform a Fill."
  minFillAmount: BigInt!

  ######################## Pricing ########################

  """
  The Pricing Type states whether this PodOrder uses FIXED or DYNAMIC pricing.

  null = V1 FIXED  = use `pricePerPod`
  0    = V2 FIXED  = use `pricePerPod`
  1    = V2 DYNAMIC = use `pricingFunction`
  """
  pricingType: Int

  """
  [V1] The FIXED price per Pod denominated in Beans.

  Ex. `pricePerPod = 10000` indicates a price of 0.01 Beans per Pod.

  If `pricingType = 1`, this field is initialized to `0` and should be ignored.
  """
  pricePerPod: Int!

  """
  [V2] The FIXED or DYNAMIC pricing function, encoded as bytes.

  This must be decoded client-side, see `LibPolynomial.sol` for more info.

  null    = V1 FIXED    = use `pricePerPod`
  "0x"    = V2 FIXED    = use `pricePerPod`
  "0x..." = V2 DYNAMIC  = use `pricingFunction`
  """
  pricingFunction: Bytes

  ######################## Amounts ########################

  """
  The original number of Beans locked in the PodOrder.

  Does NOT change as Fills occur.
  Always deterministic, since the Farmer must lock Beans for PodOrder fulfillment.

  If FIXED (V1): `amount * pricePerPod` fields emitted in PodOrderCreated.
  If FIXED (V2): `amount` field emitted in PodOrderCreated.
  If DYNAMIC (V2): `amount` field emitted in PodOrderCreated.
  """
  beanAmount: BigInt!

  """
  The current number of Pods that have been purchased by this PodOrder.

  Increases during each subsequent Fill.
  If pricingType = FIXED: `0 <= podAmountFilled <= podAmount`
  If pricingType = DYNAMIC: No constraint, since `podAmount` is unknown.

  Upon PodOrder cancellation, this value is locked.
  """
  podAmountFilled: BigInt!

  """
  The current number of Beans spent to acquire Pods.

  Increases during each subsequent Fill:
  `0 <= beanAmountFilled <= beanAmount`

  Upon PodOrder cancellation, this value is locked.
  """
  beanAmountFilled: BigInt!

  ######################## Activity ########################

  "All Fills associated with this PodOrder."
  fills: [PodFill!]!

  ######################## Metadata ########################

  "Current status of order."
  status: MarketStatus!

  "Timestamp of PodOrder creation."
  createdAt: BigInt!

  "Timestamp of last PodOrder update. Changes when a PodOrder is Filled or Cancelled."
  updatedAt: BigInt!

  "Transaction hash when this PodOrder entity was created."
  creationHash: Bytes!
}

type PodFill @entity {
  "Beanstalk address - Order/Listing index - transaction hash"
  id: ID!
  "Marketplace associated with this fill"
  podMarketplace: PodMarketplace!
  "Creation timestamp"
  createdAt: BigInt!
  "Associated listing, if any"
  listing: PodListing
  "Associated order, if any"
  order: PodOrder
  "Account that is sending pods"
  fromFarmer: Farmer!
  "Account that is receiving pods"
  toFarmer: Farmer!
  "Number of pods filled"
  amount: BigInt!
  "Where these pods were in line when filled"
  placeInLine: BigInt!
  "Index of plot transferred"
  index: BigInt!
  "Start of plot transferred"
  start: BigInt!
  "Total beans used to fill listing/order"
  costInBeans: BigInt!
}

##################################
##### Fertilizer Entities #####
##################################

# Global Fertilizer state for tracking
type Fertilizer @entity {
  "Token address for fert"
  id: Bytes!
  "'beanstalk'"
  beanstalk: String!
  "Total overall suppy of fert tokens"
  supply: BigInt!
  "Supply from L1 which has not been minted on L2 yet"
  unmigratedL1Supply: BigInt
  tokens: [FertilizerToken!]! @derivedFrom(field: "fertilizer")
}

# Id-level Fertilizer entity
type FertilizerToken @entity {
  "Total BPF for purchase"
  id: ID!
  fertilizer: Fertilizer!
  "Total supply for this Humidity"
  supply: BigInt!
  "Humidity paid for this ID"
  humidity: BigDecimal!
  "Ending BPF on creation"
  endBpf: BigInt!
  "Starting BPF on creation"
  startBpf: BigInt!
  "Season created"
  season: Int!
  balances: [FertilizerBalance!]! @derivedFrom(field: "fertilizerToken")
}

type FertilizerBalance @entity {
  "Fertilizer Token - Farmer address"
  id: ID!
  fertilizerToken: FertilizerToken!
  farmer: Farmer!
  "Current balance of token"
  amount: BigInt!
}

type FertilizerYield @entity {
  "Season of data points"
  id: ID!
  "Current season"
  season: Int!
  "Bean EMA Window"
  emaWindow: EmaWindow!
  "Current humidity"
  humidity: BigDecimal!
  "Current outstanding fert"
  outstandingFert: BigInt!
  "Current Bean EMA"
  beansPerSeasonEMA: BigDecimal!
  "BPF delta"
  deltaBpf: BigDecimal!
  "Simplified APY for new Fert"
  simpleAPY: BigDecimal!
  "Block timestamp at creation"
  createdAt: BigInt!
}

##################################
##### Event-Level Data #####
##################################

interface MarketplaceEvent {
  "{ Event type }-{ Transaction hash }-{ Log index }"
  id: ID!
  "Transaction hash of the transaction that emitted this event"
  hash: Bytes!
  "Event log index. For transactions that don't emit event, create arbitrary index starting from 0"
  logIndex: Int!
  "Block number of this event"
  blockNumber: BigInt!
  "Timestamp of this event"
  createdAt: BigInt!
}

type Chop @entity(immutable: true) {
  "(chop|convert)-{ Transaction hash }-{ Log index }"
  id: ID!
  "Account address"
  farmer: Farmer!
  "The unripe token which was chopped"
  unripeToken: UnripeToken!
  "Unripe token amount which was chopped"
  unripeAmount: BigInt!
  "Bdv of the unripe tokens which were chopped"
  unripeBdv: BigInt!
  "The underlying ERC20 token received by `farmer` as a result of this chop"
  underlyingToken: WhitelistTokenSetting!
  "Amount of underlying tokens `farmer` received"
  underlyingAmount: BigInt!
  "Amount of bdv `farmer` received"
  underlyingBdv: BigInt!
  "The effective chop rate for this chop"
  chopRate: BigDecimal!
  "Transaction hash of the transaction that emitted this event"
  hash: Bytes!
  "The block number of this event"
  blockNumber: BigInt!
  "Timestamp of this chop"
  createdAt: BigInt!
}

type PodListingCreated implements MarketplaceEvent @entity(immutable: true) {
  "podListingCreated-{ Transaction hash }-{ Log index }"
  id: ID!
  "Transaction hash of the transaction that emitted this event"
  hash: Bytes!
  "Event log index. For transactions that don't emit event, create arbitrary index starting from 0"
  logIndex: Int!
  "Historical ID for joins"
  historyID: String!
  "Account creating the listing"
  account: Bytes!
  "Where these pods were in line when listed"
  placeInLine: BigInt!
  "Index of the plot listed"
  index: BigInt!
  "Start value of the plot listed"
  start: BigInt!
  "Amount of pods listed"
  amount: BigInt!
  "Price per pod"
  pricePerPod: Int!
  "Max index for listing"
  maxHarvestableIndex: BigInt!
  "Minimum fill amount"
  minFillAmount: BigInt!
  "Claim to location"
  mode: Int!
  "Pricing Function Data"
  pricingFunction: Bytes
  "Pricing Type"
  pricingType: Int
  "Block number of this event"
  blockNumber: BigInt!
  "Timestamp of this event"
  createdAt: BigInt!
}

type PodListingFilled implements MarketplaceEvent @entity(immutable: true) {
  "podListingFilled-{ Transaction hash }-{ Log index }"
  id: ID!
  "Transaction hash of the transaction that emitted this event"
  hash: Bytes!
  "Event log index. For transactions that don't emit event, create arbitrary index starting from 0"
  logIndex: Int!
  "Historical ID for joins"
  historyID: String!
  "Account selling pods"
  fromFarmer: Bytes!
  "Account buying pods"
  toFarmer: Bytes!
  "Where these pods were in line when filled"
  placeInLine: BigInt!
  "Index of the plot transferred"
  index: BigInt!
  "Start of the plot transferred"
  start: BigInt!
  "Number of pods transferred"
  amount: BigInt!
  "Beans paid to fill the listing"
  costInBeans: BigInt
  "Block number of this event"
  blockNumber: BigInt!
  "Timestamp of this event"
  createdAt: BigInt!
}

type PodListingCancelled implements MarketplaceEvent @entity(immutable: true) {
  "seedChange-{ Transaction hash }-{ Log index }"
  id: ID!
  "Transaction hash of the transaction that emitted this event"
  hash: Bytes!
  "Event log index. For transactions that don't emit event, create arbitrary index starting from 0"
  logIndex: Int!
  "Historical ID for joins"
  historyID: String!
  "Account cancelling listing"
  account: Bytes!
  "Where these pods were in line when cancelled"
  placeInLine: BigInt!
  "Index of plot listing being cancelled"
  index: BigInt!
  "Block number of this event"
  blockNumber: BigInt!
  "Timestamp of this event"
  createdAt: BigInt!
}

type PodOrderCreated implements MarketplaceEvent @entity(immutable: true) {
  "podOrderCreated-{ Transaction hash }-{ Log index }"
  id: ID!
  "Transaction hash of the transaction that emitted this event"
  hash: Bytes!
  "Event log index. For transactions that don't emit event, create arbitrary index starting from 0"
  logIndex: Int!
  "Historical ID for joins"
  historyID: String!
  "Account creating the listing"
  account: Bytes!
  "ID of the pod order"
  orderId: String!
  """
  The represented value emitted with this event changed with BIP-29 at block 15277986
  Pre  BIP-29: The number of pods ordered is emitted
  Post BIP-29: The number of beans supplied for the order is emitted.
  """
  amount: BigInt!
  "Price per pod"
  pricePerPod: Int!
  "Max place in line"
  maxPlaceInLine: BigInt!
  "Pricing Function Data"
  pricingFunction: Bytes
  "Pricing Type"
  pricingType: Int
  "Block number of this event"
  blockNumber: BigInt!
  "Timestamp of this event"
  createdAt: BigInt!
}

type PodOrderFilled implements MarketplaceEvent @entity(immutable: true) {
  "podOrderFilled-{ Transaction hash }-{ Log index }"
  id: ID!
  "Transaction hash of the transaction that emitted this event"
  hash: Bytes!
  "Event log index. For transactions that don't emit event, create arbitrary index starting from 0"
  logIndex: Int!
  "Historical ID for joins"
  historyID: String!
  "Account selling pods"
  fromFarmer: Bytes!
  "Account buying pods"
  toFarmer: Bytes!
  "Where these pods were in line when filled"
  placeInLine: BigInt!
  "Index of the plot transferred"
  index: BigInt!
  "Start of the plot transferred"
  start: BigInt!
  "Number of pods transferred"
  amount: BigInt!
  "Beans paid to fill the order"
  costInBeans: BigInt
  "Block number of this event"
  blockNumber: BigInt!
  "Timestamp of this event"
  createdAt: BigInt!
}

type PodOrderCancelled implements MarketplaceEvent @entity(immutable: true) {
  "podOrderCancelled-{ Transaction hash }-{ Log index }"
  id: ID!
  "Transaction hash of the transaction that emitted this event"
  hash: Bytes!
  "Event log index. For transactions that don't emit event, create arbitrary index starting from 0"
  logIndex: Int!
  "Historical ID for joins"
  historyID: String!
  "Account cancelling listing"
  account: Bytes!
  "ID of order cancelled"
  orderId: String!
  "Block number of this event"
  blockNumber: BigInt!
  "Timestamp of this event"
  createdAt: BigInt!
}

# For each applicable address there will be a max of two germinating entities - one even and one odd
type Germinating @entity {
  "Address-(EVEN|ODD)"
  id: ID!
  "Address of the token or account which is germinating"
  address: Bytes!
  "EVEN or ODD"
  type: String!
  "True when the address is a farmer account"
  isFarmer: Boolean!
  "The season in which the germination started"
  season: Int!
  "Germinating stalk. This only applies to farmer/protocol address"
  stalk: BigInt!
  "Germinating tokens. This only applies to a Token address"
  tokenAmount: BigInt!
  "Germinating bdv. This only applies to a Token address"
  bdv: BigInt!
}

# This entity exists solely for resolving the issue in LibGerminate when deposits from multiple seasons
# complete their germination (the event emission itself has a bug)
type PrevFarmerGerminatingEvent @entity {
  "Farmer address"
  id: Bytes!
  "The `block.number` of the `FarmerGerminatingStalkBalanceChanged` event"
  eventBlock: BigInt!
  "The `logIndex` of the `FarmerGerminatingStalkBalanceChanged` event"
  logIndex: BigInt!
  "The value for `deltaGerminatingStalk` from this previous `FarmerGerminatingStalkBalanceChanged` event."
  deltaGerminatingStalk: BigInt!
}

type TractorReward @entity {
  "{farmer}-{rewardType}-{rewardToken}"
  id: ID!

  "The farmer associated to this reward"
  farmer: Farmer!
  "The type of this reward"
  rewardType: Int!
  "The token given for this reward"
  rewardToken: Bytes!

  "For account=publisher - Total executed orders with these reward settings."
  publisherExecutions: Int!
  "For account=publisher - Total amount paid to the operator for executed orders."
  publisherPosAmount: BigInt!
  "For account=publisher - Total amount received from the operator for executed orders."
  publisherNegAmount: BigInt!

  "For account=operator - Total executed orders with these reward settings."
  operatorExecutions: Int!
  "For account=operator - Total amount received from the publisher for executed orders."
  operatorPosAmount: BigInt!
  "For account=operator - Total amount paid to the publisher for executed orders."
  operatorNegAmount: BigInt!
}

type Tractor @entity {
  "'tractor'"
  id: ID!
  "Total number of tractor executions (# times the `Tractor` event is emitted)"
  totalExecutions: Int!
  "Total amount of Bean tips paid from publisher to operator. Does not include any other tokens."
  totalPosBeanTips: BigInt!
  "Total amount of Bean tips paid from operator to publisher. Does not include any other tokens."
  totalNegBeanTips: BigInt!

  "Season when the previous hourly snapshot was taken/updated"
  lastHourlySnapshotSeason: Int
  "Day of when the previous daily snapshot was taken/updated"
  lastDailySnapshotDay: BigInt
  "Link to hourly snapshot data"
  hourlySnapshots: [TractorHourlySnapshot!]! @derivedFrom(field: "tractor")
  "Link to daily snapshot data"
  dailySnapshots: [TractorDailySnapshot!]! @derivedFrom(field: "tractor")
}

type TractorHourlySnapshot @entity {
  "Tractor ID - Season"
  id: ID!
  "Season for the snapshot"
  season: Int!
  "Tractor associated with this snapshot"
  tractor: Tractor!

  "Point in time totalExecutions"
  totalExecutions: Int!
  "Point in time totalPosBeanTips"
  totalPosBeanTips: BigInt!
  "Point in time totalNegBeanTips"
  totalNegBeanTips: BigInt!

  deltaTotalExecutions: Int!
  deltaTotalPosBeanTips: BigInt!
  deltaTotalNegBeanTips: BigInt!

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type TractorDailySnapshot @entity {
  "Tractor ID - Day"
  id: ID!
  "Season for the snapshot"
  season: Int!
  "Tractor associated with this snapshot"
  tractor: Tractor!

  "Point in time totalExecutions"
  totalExecutions: Int!
  "Point in time totalPosBeanTips"
  totalPosBeanTips: BigInt!
  "Point in time totalNegBeanTips"
  totalNegBeanTips: BigInt!

  deltaTotalExecutions: Int!
  deltaTotalPosBeanTips: BigInt!
  deltaTotalNegBeanTips: BigInt!

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

### LEGACY/BEANSTALK ###

type UnripeToken @entity {
  "Token Address"
  id: Bytes!
  "The ripe token underlying this unripe asset"
  underlyingToken: WhitelistTokenSetting!
  "The total amount of `underlyingToken` for this unripe token (getTotalUnderlying)"
  totalUnderlying: BigInt!
  "The amount of `underlyingToken` corresponding to one of this unripe token (getUnderlyingPerUnripeToken)"
  amountUnderlyingOne: BigInt!
  "The bdv of `amountUnderlyingOne` of `underlyingToken`. Assumed to not always be the same as bdv(id)"
  bdvUnderlyingOne: BigInt!
  "The amount of `underlyingToken` which would be received if one of this unripe token were to be chopped (getPenalty)"
  choppableAmountOne: BigInt!
  "The bdv that would be received if one of this unripe token were to be chopped"
  choppableBdvOne: BigInt!
  "The chop rate, in percent (getPercentPenalty)"
  chopRate: BigDecimal!
  "The amount recapitalized, in percent (getRecapFundedPercent)"
  recapPercent: BigDecimal!
  "The total amount of this unripe token which has been chopped"
  totalChoppedAmount: BigInt!
  "The total bdv of this unripe token which has been chopped"
  totalChoppedBdv: BigInt!
  "The total bdv of all `underlyingToken` that has been received from chopping"
  totalChoppedBdvReceived: BigInt!
  "Season when the previous hourly snapshot was taken/updated"
  lastHourlySnapshotSeason: Int
  "Day of when the previous daily snapshot was taken/updated"
  lastDailySnapshotDay: BigInt
  "Link to hourly snapshot data"
  hourlySnapshots: [UnripeTokenHourlySnapshot!]! @derivedFrom(field: "unripeToken")
  "Link to daily snapshot data"
  dailySnapshots: [UnripeTokenDailySnapshot!]! @derivedFrom(field: "unripeToken")
}

type UnripeTokenHourlySnapshot @entity {
  "UnripeToken ID - Season"
  id: ID!
  "Season for the snapshot"
  season: Int!
  "Unripe token associated with this snapshot"
  unripeToken: UnripeToken!

  "Point in time ripe token underlying this unripe asset"
  underlyingToken: WhitelistTokenSetting!
  "Point in time total amount of `underlyingToken` for this unripe token (getTotalUnderlying)"
  totalUnderlying: BigInt!
  "Point in time amount of `underlyingToken` corresponding to one of this unripe token (getUnderlyingPerUnripeToken)"
  amountUnderlyingOne: BigInt!
  "Point in time bdv of `amountUnderlyingOne` of `underlyingToken`. Assumed to not always be the same as bdv(id)"
  bdvUnderlyingOne: BigInt!
  "Point in time amount of `underlyingToken` which would be received if one of this unripe token were to be chopped (getPenalty)"
  choppableAmountOne: BigInt!
  "Point in time bdv that would be received if one of this unripe token were to be chopped"
  choppableBdvOne: BigInt!
  "Point in time chop rate, in percent (getPercentPenalty)"
  chopRate: BigDecimal!
  "Point in time amount recapitalized, in percent (getRecapFundedPercent)"
  recapPercent: BigDecimal!
  "Point in time total amount of this unripe token which has been chopped"
  totalChoppedAmount: BigInt!
  "Point in time total bdv of this unripe token which has been chopped"
  totalChoppedBdv: BigInt!
  "Point in time total bdv of all `underlyingToken` that has been received from chopping"
  totalChoppedBdvReceived: BigInt!

  deltaUnderlyingToken: Boolean!
  "Note that the contents of this field are nonsense when deltaUnderlyingToken = true"
  deltaTotalUnderlying: BigInt!
  "Note that the contents of this field are nonsense when deltaUnderlyingToken = true"
  deltaAmountUnderlyingOne: BigInt!
  deltaBdvUnderlyingOne: BigInt!
  "Note that the contents of this field are nonsense when deltaUnderlyingToken = true"
  deltaChoppableAmountOne: BigInt!
  deltaChoppableBdvOne: BigInt!
  deltaChopRate: BigDecimal!
  deltaRecapPercent: BigDecimal!
  deltaTotalChoppedAmount: BigInt!
  deltaTotalChoppedBdv: BigInt!
  deltaTotalChoppedBdvReceived: BigInt!

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type UnripeTokenDailySnapshot @entity {
  "UnripeToken ID - Day"
  id: ID!
  "Last season for the snapshot"
  season: Int!
  "Unripe token associated with this snapshot"
  unripeToken: UnripeToken!

  "Point in time ripe token underlying this unripe asset"
  underlyingToken: WhitelistTokenSetting!
  "Point in time total amount of `underlyingToken` for this unripe token (getTotalUnderlying)"
  totalUnderlying: BigInt!
  "Point in time amount of `underlyingToken` corresponding to one of this unripe token (getUnderlyingPerUnripeToken)"
  amountUnderlyingOne: BigInt!
  "Point in time bdv of `amountUnderlyingOne` of `underlyingToken`. Assumed to not always be the same as bdv(id)"
  bdvUnderlyingOne: BigInt!
  "Point in time amount of `underlyingToken` which would be received if one of this unripe token were to be chopped (getPenalty)"
  choppableAmountOne: BigInt!
  "Point in time bdv that would be received if one of this unripe token were to be chopped"
  choppableBdvOne: BigInt!
  "Point in time chop rate, in percent (getPercentPenalty)"
  chopRate: BigDecimal!
  "Point in time amount recapitalized, in percent (getRecapFundedPercent)"
  recapPercent: BigDecimal!
  "Point in time total amount of this unripe token which has been chopped"
  totalChoppedAmount: BigInt!
  "Point in time total bdv of this unripe token which has been chopped"
  totalChoppedBdv: BigInt!
  "Point in time total bdv of all `underlyingToken` that has been received from chopping"
  totalChoppedBdvReceived: BigInt!

  deltaUnderlyingToken: Boolean!
  "Note that the contents of this field are nonsense when deltaUnderlyingToken = true"
  deltaTotalUnderlying: BigInt!
  "Note that the contents of this field are nonsense when deltaUnderlyingToken = true"
  deltaAmountUnderlyingOne: BigInt!
  deltaBdvUnderlyingOne: BigInt!
  "Note that the contents of this field are nonsense when deltaUnderlyingToken = true"
  deltaChoppableAmountOne: BigInt!
  deltaChoppableBdvOne: BigInt!
  deltaChopRate: BigDecimal!
  deltaRecapPercent: BigDecimal!
  deltaTotalChoppedAmount: BigInt!
  deltaTotalChoppedBdv: BigInt!
  deltaTotalChoppedBdvReceived: BigInt!

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

# Intention of this entity is to store info relevant to various (multiple) gauges.
# Gauge 0 and 1 are already on the silo/field entity directly, however continuing this pattern
# will quickly bloat those schemas. Therefore it is preferable to put all of the info here.
# Ultimately, the intention is to remove those values from the silo/field entities, but in practice it may not happen.
type GaugesInfo @entity {
  "'gauges'"
  id: ID!

  "Whether the Cultivation Factor gauge is active"
  g0IsActive: Boolean!
  "Whether the Convert Down Penalty gauge is active"
  g1IsActive: Boolean!
  "Whether the Convert Up Bonus gauge is active"
  g2IsActive: Boolean!

  "Cultivation Factor, in percent (i.e. 20.5 = 20.5% cultivation factor)"
  g0CultivationFactor: BigDecimal

  "Convert down penalty ratio"
  g1ConvertDownPenalty: BigDecimal

  "Convert Up Bonus current bonus stalk per bdv"
  g2BonusStalkPerBdv: BigInt
  "Convert Up Bonus seasonal max convert capacity (in bdv) that is eligible for a bonus"
  g2MaxConvertCapacity: BigInt
  "Convert Up Bonus bdv converted this season"
  g2BdvConvertedThisSeason: BigInt
  "Convert Up Bonus max recorded negative twaDeltaB while the bonus was active"
  g2MaxTwaDeltaB: BigInt

  "Season when the previous hourly snapshot was taken/updated"
  lastHourlySnapshotSeason: Int
  "Day of when the previous daily snapshot was taken/updated"
  lastDailySnapshotDay: BigInt
  "Link to hourly snapshot data"
  hourlySnapshots: [GaugesInfoHourlySnapshot!]! @derivedFrom(field: "gaugesInfo")
  "Link to daily snapshot data"
  dailySnapshots: [GaugesInfoDailySnapshot!]! @derivedFrom(field: "gaugesInfo")
}

type GaugesInfoHourlySnapshot @entity {
  "Gauge ID - Season"
  id: ID!
  "Season for the snapshot"
  season: Int!
  "Unripe token associated with this snapshot"
  gaugesInfo: GaugesInfo!

  g0IsActive: Boolean!
  g1IsActive: Boolean!
  g2IsActive: Boolean!
  g0CultivationFactor: BigDecimal
  g1ConvertDownPenalty: BigDecimal
  g2BonusStalkPerBdv: BigInt
  g2MaxConvertCapacity: BigInt
  g2BdvConvertedThisSeason: BigInt
  g2MaxTwaDeltaB: BigInt

  deltaG0IsActive: Boolean!
  deltaG1IsActive: Boolean!
  deltaG2IsActive: Boolean!
  deltaG0CultivationFactor: BigDecimal
  deltaG1ConvertDownPenalty: BigDecimal
  deltaG2BonusStalkPerBdv: BigInt
  deltaG2MaxConvertCapacity: BigInt
  deltaG2BdvConvertedThisSeason: BigInt
  deltaG2MaxTwaDeltaB: BigInt

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}

type GaugesInfoDailySnapshot @entity {
  "Gauge ID - Day"
  id: ID!
  "Season for the snapshot"
  season: Int!
  "Unripe token associated with this snapshot"
  gaugesInfo: GaugesInfo!

  g0IsActive: Boolean!
  g1IsActive: Boolean!
  g2IsActive: Boolean!
  g0CultivationFactor: BigDecimal
  g1ConvertDownPenalty: BigDecimal
  g2BonusStalkPerBdv: BigInt
  g2MaxConvertCapacity: BigInt
  g2BdvConvertedThisSeason: BigInt
  g2MaxTwaDeltaB: BigInt

  deltaG0IsActive: Boolean!
  deltaG1IsActive: Boolean!
  deltaG2IsActive: Boolean!
  deltaG0CultivationFactor: BigDecimal
  deltaG1ConvertDownPenalty: BigDecimal
  deltaG2BonusStalkPerBdv: BigInt
  deltaG2MaxConvertCapacity: BigInt
  deltaG2BdvConvertedThisSeason: BigInt
  deltaG2MaxTwaDeltaB: BigInt

  "Timestamp of initial snapshot creation"
  createdAt: BigInt!
  "Timestamp of last entity update"
  updatedAt: BigInt!
}
